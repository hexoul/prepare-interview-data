{
  "questions": [
    {
      "question": "Array에 대한 적절한 설명은?",
      "choices": [
        "계층적인 구조를 가진다.",
        "일반적으로 같은 타입으로만 이루어진다.",
        "불변성 (immutability) 을 가진다.",
        "위에 언급된 모두 해당"
      ],
      "answer": 2,
      "explanation": "Array는 선형 구조이며, 변경이 가능하므로 immutable이 아니라 mutable입니다.",
      "references": [
        {"Array": "https://en.wikipedia.org/wiki/Array_data_structure"},
        {"Immutability": "https://en.wikipedia.org/wiki/Immutable_object"}
      ]
    },
    {
      "question": "Array 첫번째 요소의 인덱스는?",
      "choices": [
        "-1",
        "0",
        "1",
        "2"
      ],
      "answer": 2,
      "explanation": "Array뿐만 아니라 컴퓨터에서 인덱스는 일반적으로 0으로 시작합니다.",
      "references": [
        {"Array": "https://en.wikipedia.org/wiki/Array_data_structure"}
      ]
    },
    {
      "question": "Array에서 IndexOutOfBoundsException은 언제 발생할 수 있는가?",
      "choices": [
        "Compile time",
        "Runtime",
        "비정상 종료 시",
        "발생하지 않는다."
      ],
      "answer": 2,
      "explanation": "Array의 범위를 벗어나는 인덱스에 실제로 접근하려할 때 발생하므로, 컴파일과는 관계없이 프로그램 실행 중인 런타임에 발생할 수 있습니다.",
      "references": [
        {"Array": "https://en.wikipedia.org/wiki/Array_data_structure"},
        {"Compile time": "https://en.wikipedia.org/wiki/Compile_time"},
        {"Runtime": "https://en.wikipedia.org/wiki/Runtime_(program_lifecycle_phase)"}
      ]
    },
    {
      "question": "int의 크기가 4 bytes 라면, 'int arr[10]'로 선언된 arr의 크기는?",
      "choices": [
        "10 bytes",
        "14 bytes",
        "40 bytes",
        "44 bytes"
      ],
      "answer": 3,
      "explanation": "10개의 요소가 저장될 수 있는 크기를 나타내므로 10 * 4로 계산할 수 있습니다.",
      "references": [
        {"Array": "https://en.wikipedia.org/wiki/Array_data_structure"}
      ]
    },
    {
      "question": "int의 크기가 4 bytes 이고 'int arr[10]'로 선언됐다면 arr[10]의 크기는?",
      "choices": [
        "0 byte",
        "4 bytes",
        "10 bytes",
        "40 bytes"
      ],
      "answer": 1,
      "explanation": "'[10]'은 인덱스가 10에 해당하는 요소를 선택하는 문법입니다. 그런데 위와 같이 선언됐을 경우 array의 길이는 10이지만 인덱스가 0부터 시작하여 9까지만 존재합니다. 따라서 인덱스가 10인 요소는 존재하지 않는다는 것을 알 수 있습니다.",
      "references": [
        {"Array": "https://en.wikipedia.org/wiki/Array_data_structure"}
      ]
    },
    {
      "question": "다음 중 어떤 개념에서 array를 활용할 여지가 있는가?",
      "choices": [
        "Binary tree",
        "Process scheduling",
        "Caching",
        "Spatial locality"
      ],
      "answer": 4,
      "explanation": "Array는 선형 구조로 메모리 상의 연속된 블록에 저장되므로, OS가 spatial locality를 고려하여 데이터를 추가적으로 가져올 때 도움이 됩니다.",
      "references": [
        {"Array": "https://en.wikipedia.org/wiki/Array_data_structure"},
        {"Locality": "https://en.wikipedia.org/wiki/Locality_of_reference"}
      ]
    },
    {
      "question": "집합이 물리적으로 연속된 공간에 저장되지않고 각 요소가 다음 요소를 가리키는 포인터를 가지고 있는 선형 집합을 ___라 한다.",
      "choices": [
        "Node list",
        "Array list",
        "Linked list",
        "Unordered list"
      ],
      "answer": 3,
      "explanation": "-",
      "references": [
        {"[한] Linked list": "https://ko.wikipedia.org/wiki/%EC%97%B0%EA%B2%B0_%EB%A6%AC%EC%8A%A4%ED%8A%B8"},
        {"Linked list": "https://en.wikipedia.org/wiki/Linked_list"}
      ]
    },
    {
      "question": "단일 연결 리스트 (singly linked list) 와 head 포인터가 있을 때, 리스트의 제일 앞에 삽입하는 시간 복잡도는 ___이고, 제일 뒤에 삽입하는 시간 복잡도는 ___이다.",
      "choices": [
        "O(1), O(1)",
        "O(1), O(n)",
        "O(n), O(1)",
        "O(n), O(n)"
      ],
      "answer": 2,
      "explanation": "제일 앞에 삽입하는 것은 head 포인터를 통해 바로 가능하지만, 제일 뒤에 삽입하는 것은 tail 포인터가 없기 때문에 head에서부터 마지막까지 탐색하여야 해서 O(n)이 됩니다.",
      "references": [
        {"[한] Linked list": "https://ko.wikipedia.org/wiki/%EC%97%B0%EA%B2%B0_%EB%A6%AC%EC%8A%A4%ED%8A%B8"},
        {"Linked list": "https://en.wikipedia.org/wiki/Linked_list"},
        {"[한] Time complexity": "https://ko.wikipedia.org/wiki/%EC%8B%9C%EA%B0%84_%EB%B3%B5%EC%9E%A1%EB%8F%84"},
        {"Time complexity": "https://en.wikipedia.org/wiki/Time_complexity"}
      ]
    },
    {
      "question": "Linked list의 기본 단위인 노드 (node)는 실제 데이터 값과 ___를 저장하고 있다.",
      "choices": [
        "Head pointer",
        "Tail pointer",
        "Node pointer",
        "Node"
      ],
      "answer": 3,
      "explanation": "Head 또는 tail 포인터는 linked list 자체에는 포함되지않는 외부 요소입니다. 노드는 물리적으로 연속된 공간에 저장된 것이 아니기 때문에 또 다른 노드를 내부적으로 저장하는 경우는 없고 다음 노드가 저장된 주소만 가지고 있습니다.",
      "references": [
        {"[한] Linked list": "https://ko.wikipedia.org/wiki/%EC%97%B0%EA%B2%B0_%EB%A6%AC%EC%8A%A4%ED%8A%B8"},
        {"Linked list": "https://en.wikipedia.org/wiki/Linked_list"}
      ]
    },
    {
      "question": "Linked list의 탐색 시간 복잡도는?",
      "choices": [
        "O(1)",
        "O(n)",
        "O(n^2)",
        "O(n^3)"
      ],
      "answer": 2,
      "explanation": "Linked list는 선형 자료구조이기 때문에 특별한 장치를 두지 않는 한 선형 검색만 가능합니다.",
      "references": [
        {"[한] Linked list": "https://ko.wikipedia.org/wiki/%EC%97%B0%EA%B2%B0_%EB%A6%AC%EC%8A%A4%ED%8A%B8"},
        {"Linked list": "https://en.wikipedia.org/wiki/Linked_list"},
        {"[한] Time complexity": "https://ko.wikipedia.org/wiki/%EC%8B%9C%EA%B0%84_%EB%B3%B5%EC%9E%A1%EB%8F%84"},
        {"Time complexity": "https://en.wikipedia.org/wiki/Time_complexity"}
      ]
    }
  ]
}
