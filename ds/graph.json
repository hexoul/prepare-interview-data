{
  "questions": [
    {
      "question": "이진 트리 (binary tree) 는 몇 개의 자식을 가지는가?",
      "choices": [
        "1",
        "2",
        "2개 이하",
        "2개 이상"
      ],
      "answer": 3,
      "explanation": "이진 트리 (binary tree) 란 각 노드가 최대 두 개의 자식을 가지는 자료구조입니다. e.g., 0, 1, 2",
      "references": [
        {"[한] Binary tree": "https://ko.wikipedia.org/wiki/%EC%9D%B4%EC%A7%84_%ED%8A%B8%EB%A6%AC"},
        {"Binary tree": "https://en.wikipedia.org/wiki/Binary_tree"}
      ]
    },
    {
      "question": "Binary tree를 array로 구현할 때 ___은 단점이 된다.",
      "choices": [
        "자식 노드를 찾기 어려운 점",
        "부모 노드를 찾기 어려운 점",
        "구현이 어려운 점",
        "공간 낭비가 생길 수 있는 점"
      ],
      "answer": 4,
      "explanation": "Array로는 구현이 쉽고 부모 또는 자식 노드의 위치를 수학적으로 바로 계산할 수 있어 찾기도 쉽습니다. 그러나 완전 이진 트리 (complete binary tree) 가 아닐 경우 빈 값을 가진 요소들이 생겨 공간 낭비가 생길 수 있습니다.",
      "references": [
        {"Array for Binary tree": "https://en.wikipedia.org/wiki/Binary_tree#Arrays"},
        {"[한] Binary tree": "https://ko.wikipedia.org/wiki/%EC%9D%B4%EC%A7%84_%ED%8A%B8%EB%A6%AC"},
        {"Binary tree": "https://en.wikipedia.org/wiki/Binary_tree"}
      ]
    },
    {
      "question": "Binary tree를 array로 구현할 때 높이가 H까지 증가한다면 array의 크기는 몇이 적절한가?",
      "choices": [
        "H",
        "2H",
        "H^2 - 1",
        "2^H - 1"
      ],
      "answer": 4,
      "explanation": "이진 트리가 높이에 따라 가질 수 있는 최대 노드 개수를 구하면 됩니다. 최대 개수가 되려면 자식 노드를 항상 두 개씩 가져야 하므로 높이가 증가할 때마다 두 배씩 늘어난 다는 것을 알 수 있습니다. 예를 들어 높이가 3이라면 1+2+4, 4라면 1+2+4+8이 됩니다. 따라서 점화식으로부터 등비수열의 합을 통해 2^H - 1 를 구할 수 있습니다.",
      "references": [
        {"Array for Binary tree": "https://en.wikipedia.org/wiki/Binary_tree#Arrays"},
        {"[한] Binary tree": "https://ko.wikipedia.org/wiki/%EC%9D%B4%EC%A7%84_%ED%8A%B8%EB%A6%AC"},
        {"Binary tree": "https://en.wikipedia.org/wiki/Binary_tree"},
        {"등비수열": "https://ko.wikipedia.org/wiki/%EB%93%B1%EB%B9%84%EC%88%98%EC%97%B4"}
      ]
    },
    {
      "question": "Binary tree를 array로 구현할 때 어떤 노드의 인덱스가 i라면 left child의 인덱스는 ___ 이다.",
      "choices": [
        "i + 1",
        "2i",
        "2i + 1",
        "2i + 2"
      ],
      "answer": 3,
      "explanation": "높이가 증가할 때마다 해당 높이의 노드들을 저장하는 크기가 두 배씩 증가하는 것을 생각해보면 left와 right child의 인덱스가 각각 (2i + 1)과 (2i + 2)가 됨을 이해할 수 있습니다.",
      "references": [
        {"Array for Binary tree": "https://en.wikipedia.org/wiki/Binary_tree#Arrays"},
        {"[한] Binary tree": "https://ko.wikipedia.org/wiki/%EC%9D%B4%EC%A7%84_%ED%8A%B8%EB%A6%AC"},
        {"Binary tree": "https://en.wikipedia.org/wiki/Binary_tree"}
      ]
    },
    {
      "question": "Binary tree를 array로 구현할 때 root가 아닌 어떤 노드의 인덱스가 i라면 부모 노드의 인덱스는 ___ 이다.",
      "choices": [
        "ceil((i - 1)/2)",
        "floor((i - 1)/2)",
        "(i - 1)/2",
        "i/2"
      ],
      "answer": 2,
      "explanation": "높이가 증가할 때마다 해당 높이의 노드들을 저장하는 크기가 두 배씩 증가하는 것을 생각해보면 left와 right child의 인덱스가 각각 (2i + 1)과 (2i + 2)가 됨을 이해할 수 있습니다.\n(2i + 1)과 (2i + 2)가 부모 노드인 i를 가리키려면 1을 뺀 뒤 2로 나눈 것에서 floor 함수로 소수점을 없애면 된다는 것을 알 수 있습니다.",
      "references": [
        {"Array for Binary tree": "https://en.wikipedia.org/wiki/Binary_tree#Arrays"},
        {"[한] Binary tree": "https://ko.wikipedia.org/wiki/%EC%9D%B4%EC%A7%84_%ED%8A%B8%EB%A6%AC"},
        {"Binary tree": "https://en.wikipedia.org/wiki/Binary_tree"}
      ]
    },
    {
      "question": "Binary tree를 array로 구현했다면 height가 3이고 모든 노드가 한 개의 자식만 가지는 트리를 표현했을 때 몇 개의 요소가 빈 값으로 남아있는가?",
      "choices": [
        "2",
        "3",
        "4",
        "5"
      ],
      "answer": 3,
      "explanation": "모든 노드가 자식을 하나만 가진다면 선형 구조처럼 되어 각 높이 당 노드가 하나만 존재합니다. 따라서 높이 = 노드의 수가 됩니다.\n높이가 3이었으므로 배열의 총 길이는 2^3 - 1 = 7이기 때문에 노드의 수를 빼주면 정답은 4가 됩니다.",
      "references": [
        {"Array for Binary tree": "https://en.wikipedia.org/wiki/Binary_tree#Arrays"},
        {"[한] Binary tree": "https://ko.wikipedia.org/wiki/%EC%9D%B4%EC%A7%84_%ED%8A%B8%EB%A6%AC"},
        {"Binary tree": "https://en.wikipedia.org/wiki/Binary_tree"}
      ]
    },
    {
      "question": "Sparse binary tree에 대한 설명으로 맞는 것은?",
      "choices": [
        "배열로 표현하면 메모리에 비효율적이다.",
        "Linked list로 표현하면 메모리에 비효율적이다.",
        "Complete binary tree는 sparse binary tree에 속한다.",
        "Dense binary tree에 비해 노드 수가 많다."
      ],
      "answer": 1,
      "explanation": "Sparse binary tree란 complete binary tree 대비 노드 수가 적은, 비어있는 부분이 많은 트리입니다. 따라서 배열로 표현할 경우에는 빈 공간이 많이 생겨 메모리에 비효율적입니다. Linked list로는 실제로 노드가 있을 때에만 연결되므로 배열보다 저장 공간을 적게 씁니다.",
      "references": [
        {"[한] Binary tree": "https://ko.wikipedia.org/wiki/%EC%9D%B4%EC%A7%84_%ED%8A%B8%EB%A6%AC"},
        {"Binary tree": "https://en.wikipedia.org/wiki/Binary_tree"}
      ]
    },
    {
      "question": "Binary tree를 linked list로 표현할 때의 장점이 아닌 것은?",
      "choices": [
        "저장 공간에 낭비가 없다.",
        "삽입 구현이 쉽다.",
        "삭제 구현이 쉽다.",
        "Random access가 가능하다."
      ],
      "answer": 3,
      "explanation": "Linked list의 경우 임의의 노드에 도달하기 위해 root부터 탐색해야 합니다.",
      "references": [
        {"[한] Binary tree": "https://ko.wikipedia.org/wiki/%EC%9D%B4%EC%A7%84_%ED%8A%B8%EB%A6%AC"},
        {"Binary tree": "https://en.wikipedia.org/wiki/Binary_tree"}
      ]
    },
    {
      "question": "트리 순회 (tree traversal) 방법이 아닌 것은?",
      "choices": [
        "전위 순회 (Pre-order)",
        "중위 순회 (In-order)",
        "후위 순회 (Post-order)",
        "무작위 순회 (Random order)"
      ],
      "answer": 4,
      "explanation": "트리 자료구조에서 무작위는 적합하지 않습니다.",
      "references": [
        {"[한] Tree traversal": "https://ko.wikipedia.org/wiki/%ED%8A%B8%EB%A6%AC_%EC%88%9C%ED%9A%8C"},
        {"Tree traversal": "https://en.wikipedia.org/wiki/Tree_traversal"}
      ]
    },
    {
      "question": "다음 트리 순회 방법들 중 특성이 다른 하나는?",
      "choices": [
        "Pre-order",
        "In-order",
        "Post-order",
        "Level order"
      ],
      "answer": 4,
      "explanation": "Level order는 너비 우선 탐색 (Breadth-First Search, BFS) 인 반면 나머지는 깊이 우선 탐색 (Depth-First Search, DFS) 입니다.",
      "references": [
        {"[한] Tree traversal": "https://ko.wikipedia.org/wiki/%ED%8A%B8%EB%A6%AC_%EC%88%9C%ED%9A%8C"},
        {"Tree traversal": "https://en.wikipedia.org/wiki/Tree_traversal"},
        {"[한] BFS": "https://ko.wikipedia.org/wiki/%EB%84%88%EB%B9%84_%EC%9A%B0%EC%84%A0_%ED%83%90%EC%83%89"},
        {"BFS": "https://en.wikipedia.org/wiki/Breadth-first_search"},
        {"[한] DFS": "https://ko.wikipedia.org/wiki/%EA%B9%8A%EC%9D%B4_%EC%9A%B0%EC%84%A0_%ED%83%90%EC%83%89"},
        {"DFS": "https://en.wikipedia.org/wiki/Depth-first_search"}
      ]
    }
  ]
}
