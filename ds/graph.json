{
  "questions": [
    {
      "question": "이진 트리 (binary tree) 는 몇 개의 자식을 가지는가?",
      "choices": [
        "1",
        "2",
        "2개 이하",
        "2개 이상"
      ],
      "answer": 3,
      "explanation": "이진 트리 (binary tree) 란 각 노드가 최대 두 개의 자식을 가지는 자료구조입니다. e.g., 0, 1, 2",
      "references": [
        {"[한] Binary tree": "https://ko.wikipedia.org/wiki/%EC%9D%B4%EC%A7%84_%ED%8A%B8%EB%A6%AC"},
        {"Binary tree": "https://en.wikipedia.org/wiki/Binary_tree"}
      ]
    },
    {
      "question": "Binary tree를 array로 구현할 때 ___은 단점이 된다.",
      "choices": [
        "자식 노드를 찾기 어려운 점",
        "부모 노드를 찾기 어려운 점",
        "구현이 어려운 점",
        "공간 낭비가 생길 수 있는 점"
      ],
      "answer": 4,
      "explanation": "Array로는 구현이 쉽고 부모 또는 자식 노드의 위치를 수학적으로 바로 계산할 수 있어 찾기도 쉽습니다. 그러나 완전 이진 트리 (complete binary tree) 가 아닐 경우 빈 값을 가진 요소들이 생겨 공간 낭비가 생길 수 있습니다.",
      "references": [
        {"Array for Binary tree": "https://en.wikipedia.org/wiki/Binary_tree#Arrays"},
        {"[한] Binary tree": "https://ko.wikipedia.org/wiki/%EC%9D%B4%EC%A7%84_%ED%8A%B8%EB%A6%AC"},
        {"Binary tree": "https://en.wikipedia.org/wiki/Binary_tree"}
      ]
    },
    {
      "question": "Binary tree를 array로 구현할 때 높이가 H까지 증가한다면 array의 크기는 몇이 적절한가?",
      "choices": [
        "H",
        "2H",
        "H^2 - 1",
        "2^H - 1"
      ],
      "answer": 4,
      "explanation": "이진 트리가 높이에 따라 가질 수 있는 최대 노드 개수를 구하면 됩니다. 최대 개수가 되려면 자식 노드를 항상 두 개씩 가져야 하므로 높이가 증가할 때마다 두 배씩 늘어난 다는 것을 알 수 있습니다. 예를 들어 높이가 3이라면 1+2+4, 4라면 1+2+4+8이 됩니다. 따라서 점화식으로부터 등비수열의 합을 통해 2^H - 1 를 구할 수 있습니다.",
      "references": [
        {"Array for Binary tree": "https://en.wikipedia.org/wiki/Binary_tree#Arrays"},
        {"[한] Binary tree": "https://ko.wikipedia.org/wiki/%EC%9D%B4%EC%A7%84_%ED%8A%B8%EB%A6%AC"},
        {"Binary tree": "https://en.wikipedia.org/wiki/Binary_tree"},
        {"등비수열": "https://ko.wikipedia.org/wiki/%EB%93%B1%EB%B9%84%EC%88%98%EC%97%B4"}
      ]
    },
    {
      "question": "Binary tree를 array로 구현할 때 어떤 노드의 인덱스가 i라면 left child의 인덱스는 ___ 이다.",
      "choices": [
        "i + 1",
        "2i",
        "2i + 1",
        "2i + 2"
      ],
      "answer": 3,
      "explanation": "높이가 증가할 때마다 해당 높이의 노드들을 저장하는 크기가 두 배씩 증가하는 것을 생각해보면 left와 right child의 인덱스가 각각 (2i + 1)과 (2i + 2)가 됨을 이해할 수 있습니다.",
      "references": [
        {"Array for Binary tree": "https://en.wikipedia.org/wiki/Binary_tree#Arrays"},
        {"[한] Binary tree": "https://ko.wikipedia.org/wiki/%EC%9D%B4%EC%A7%84_%ED%8A%B8%EB%A6%AC"},
        {"Binary tree": "https://en.wikipedia.org/wiki/Binary_tree"}
      ]
    },
    {
      "question": "Binary tree를 array로 구현할 때 root가 아닌 어떤 노드의 인덱스가 i라면 부모 노드의 인덱스는 ___ 이다.",
      "choices": [
        "ceil((i - 1)/2)",
        "floor((i - 1)/2)",
        "(i - 1)/2",
        "i/2"
      ],
      "answer": 2,
      "explanation": "높이가 증가할 때마다 해당 높이의 노드들을 저장하는 크기가 두 배씩 증가하는 것을 생각해보면 left와 right child의 인덱스가 각각 (2i + 1)과 (2i + 2)가 됨을 이해할 수 있습니다.\n(2i + 1)과 (2i + 2)가 부모 노드인 i를 가리키려면 1을 뺀 뒤 2로 나눈 것에서 floor 함수로 소수점을 없애면 된다는 것을 알 수 있습니다.",
      "references": [
        {"Array for Binary tree": "https://en.wikipedia.org/wiki/Binary_tree#Arrays"},
        {"[한] Binary tree": "https://ko.wikipedia.org/wiki/%EC%9D%B4%EC%A7%84_%ED%8A%B8%EB%A6%AC"},
        {"Binary tree": "https://en.wikipedia.org/wiki/Binary_tree"}
      ]
    },
    {
      "question": "Binary tree를 array로 구현했다면 height가 3이고 모든 노드가 한 개의 자식만 가지는 트리를 표현했을 때 몇 개의 요소가 빈 값으로 남아있는가?",
      "choices": [
        "2",
        "3",
        "4",
        "5"
      ],
      "answer": 3,
      "explanation": "모든 노드가 자식을 하나만 가진다면 선형 구조처럼 되어 각 높이 당 노드가 하나만 존재합니다. 따라서 높이 = 노드의 수가 됩니다.\n높이가 3이었으므로 배열의 총 길이는 2^3 - 1 = 7이기 때문에 노드의 수를 빼주면 정답은 4가 됩니다.",
      "references": [
        {"Array for Binary tree": "https://en.wikipedia.org/wiki/Binary_tree#Arrays"},
        {"[한] Binary tree": "https://ko.wikipedia.org/wiki/%EC%9D%B4%EC%A7%84_%ED%8A%B8%EB%A6%AC"},
        {"Binary tree": "https://en.wikipedia.org/wiki/Binary_tree"}
      ]
    },
    {
      "question": "Sparse binary tree에 대한 설명으로 맞는 것은?",
      "choices": [
        "배열로 표현하면 메모리에 비효율적이다.",
        "Linked list로 표현하면 메모리에 비효율적이다.",
        "Complete binary tree는 sparse binary tree에 속한다.",
        "Dense binary tree에 비해 노드 수가 많다."
      ],
      "answer": 1,
      "explanation": "Sparse binary tree란 complete binary tree 대비 노드 수가 적은, 비어있는 부분이 많은 트리입니다. 따라서 배열로 표현할 경우에는 빈 공간이 많이 생겨 메모리에 비효율적입니다. Linked list로는 실제로 노드가 있을 때에만 연결되므로 배열보다 저장 공간을 적게 씁니다.",
      "references": [
        {"[한] Binary tree": "https://ko.wikipedia.org/wiki/%EC%9D%B4%EC%A7%84_%ED%8A%B8%EB%A6%AC"},
        {"Binary tree": "https://en.wikipedia.org/wiki/Binary_tree"}
      ]
    },
    {
      "question": "Binary tree를 linked list로 표현할 때의 장점이 아닌 것은?",
      "choices": [
        "저장 공간에 낭비가 없다.",
        "삽입 구현이 쉽다.",
        "삭제 구현이 쉽다.",
        "Random access가 가능하다."
      ],
      "answer": 4,
      "explanation": "Linked list의 경우 임의의 노드에 도달하기 위해 root부터 탐색해야 합니다.",
      "references": [
        {"[한] Binary tree": "https://ko.wikipedia.org/wiki/%EC%9D%B4%EC%A7%84_%ED%8A%B8%EB%A6%AC"},
        {"Binary tree": "https://en.wikipedia.org/wiki/Binary_tree"}
      ]
    },
    {
      "question": "트리 순회 (tree traversal) 방법이 아닌 것은?",
      "choices": [
        "전위 순회 (Pre-order)",
        "중위 순회 (In-order)",
        "후위 순회 (Post-order)",
        "무작위 순회 (Random order)"
      ],
      "answer": 4,
      "explanation": "트리 자료구조에서 무작위는 적합하지 않습니다.",
      "references": [
        {"[한] Tree traversal": "https://ko.wikipedia.org/wiki/%ED%8A%B8%EB%A6%AC_%EC%88%9C%ED%9A%8C"},
        {"Tree traversal": "https://en.wikipedia.org/wiki/Tree_traversal"}
      ]
    },
    {
      "question": "다음 트리 순회 방법들 중 특성이 다른 하나는?",
      "choices": [
        "Pre-order",
        "In-order",
        "Post-order",
        "Level order"
      ],
      "answer": 4,
      "explanation": "Level order는 너비 우선 탐색 (Breadth-First Search, BFS) 인 반면 나머지는 깊이 우선 탐색 (Depth-First Search, DFS) 입니다.",
      "references": [
        {"[한] Tree traversal": "https://ko.wikipedia.org/wiki/%ED%8A%B8%EB%A6%AC_%EC%88%9C%ED%9A%8C"},
        {"Tree traversal": "https://en.wikipedia.org/wiki/Tree_traversal"},
        {"[한] BFS": "https://ko.wikipedia.org/wiki/%EB%84%88%EB%B9%84_%EC%9A%B0%EC%84%A0_%ED%83%90%EC%83%89"},
        {"BFS": "https://en.wikipedia.org/wiki/Breadth-first_search"},
        {"[한] DFS": "https://ko.wikipedia.org/wiki/%EA%B9%8A%EC%9D%B4_%EC%9A%B0%EC%84%A0_%ED%83%90%EC%83%89"},
        {"DFS": "https://en.wikipedia.org/wiki/Depth-first_search"}
      ]
    },
    {
      "question": "왼쪽 subtree -> 현재 노드 -> 오른쪽 subtree 순으로 순회하는 방식은?",
      "choices": [
        "전위 순회 (Pre-order)",
        "중위 순회 (In-order)",
        "역순 중위 순회 (Reverse in-order)",
        "후위 순회 (Post-order)"
      ],
      "answer": 2,
      "explanation": "-",
      "references": [
        {"[한] Tree traversal": "https://ko.wikipedia.org/wiki/%ED%8A%B8%EB%A6%AC_%EC%88%9C%ED%9A%8C"},
        {"Tree traversal": "https://en.wikipedia.org/wiki/Tree_traversal"}
      ]
    },
    {
      "question": "왼쪽 subtree -> 오른쪽 subtree -> 현재 노드 순으로 순회하는 방식은?",
      "choices": [
        "전위 순회 (Pre-order)",
        "중위 순회 (In-order)",
        "역순 중위 순회 (Reverse in-order)",
        "후위 순회 (Post-order)"
      ],
      "answer": 4,
      "explanation": "-",
      "references": [
        {"[한] Tree traversal": "https://ko.wikipedia.org/wiki/%ED%8A%B8%EB%A6%AC_%EC%88%9C%ED%9A%8C"},
        {"Tree traversal": "https://en.wikipedia.org/wiki/Tree_traversal"}
      ]
    },
    {
      "question": "이진 트리의 크기를 재귀적으로 구하기위한 구현으로 알맞은 것은? 함수의 이름은 'size'이고 인자가 null로 주어지면 0을 반환한다고 가정한다.",
      "choices": [
        "size(node->left) + size(node->right)",
        "size(node->left) + size(node->right) + 1",
        "size(node->left) + size(node) + size(node->right)",
        "size(node->left) + size(node) + size(node->right) + 1"
      ],
      "answer": 2,
      "explanation": "좌우의 subtree 이외에 자신을 카운트해야 하기 때문에 '+1'을 해주어야 합니다. 보기 3과 4는 'size(node)' 때문에 자신을 무한하게 불러 stack overflow가 발생합니다.",
      "references": [
        {"[한] Tree": "https://ko.wikipedia.org/wiki/%ED%8A%B8%EB%A6%AC_%EA%B5%AC%EC%A1%B0"},
        {"Tree": "https://en.wikipedia.org/wiki/Tree_(data_structure)"}
      ]
    },
    {
      "question": "트리를 거울에 비춘 것처럼 좌우대칭으로 만들기 위한 작업으로 알맞은 것은?",
      "choices": [
        "Pre-order 순회하며 stack에 노드의 데이터를 push한 후 한번 더 순회하며 pop된 데이터로 바꾼다.",
        "In-order 순회하며 stack에 노드의 데이터를 push한 후 한번 더 순회하며 pop된 데이터로 바꾼다.",
        "재귀적으로 left와 right child의 노드의 데이터를 스왑한다.",
        "재귀적으로 left와 right child의 포인터를 스왑한다."
      ],
      "answer": 4,
      "explanation": "거울에 비춘 것처럼 좌우대칭으로 만들기 위해서는 노드가 가진 데이터 뿐만 아니라 트리의 구조가 바뀌어야합니다. 재귀적으로 subtree 단위의 교환을 반복해주면 됩니다.",
      "references": [
        {"[한] Tree": "https://ko.wikipedia.org/wiki/%ED%8A%B8%EB%A6%AC_%EA%B5%AC%EC%A1%B0"},
        {"Tree": "https://en.wikipedia.org/wiki/Tree_(data_structure)"}
      ]
    },
    {
      "question": "노드 수가 n인 이진 트리의 검색 시간 복잡도는 ___이다.",
      "choices": [
        "O(1)",
        "O(log n)",
        "O(n)",
        "O(n log n)"
      ],
      "answer": 3,
      "explanation": "이진 트리는 정렬되어 있지 않기 때문에 원하는 노드를 찾기 위해 트리를 전부 탐색해야 합니다.",
      "references": [
        {"[한] Binary tree": "https://ko.wikipedia.org/wiki/%EC%9D%B4%EC%A7%84_%ED%8A%B8%EB%A6%AC"},
        {"Binary tree": "https://en.wikipedia.org/wiki/Binary_tree"},
        {"[한] Tree traversal": "https://ko.wikipedia.org/wiki/%ED%8A%B8%EB%A6%AC_%EC%88%9C%ED%9A%8C"},
        {"Tree traversal": "https://en.wikipedia.org/wiki/Tree_traversal"}
      ]
    },
    {
      "question": "노드 수가 n인 이진 탐색 트리 (Binary Search Tree, BST) 의 검색 시간 복잡도는 ___이다.",
      "choices": [
        "O(1)",
        "O(log n)",
        "O(n)",
        "O(n log n)"
      ],
      "answer": 2,
      "explanation": "이진 트리와 달리 BST는 정렬되어 있기 때문에 이진 검색 알고리즘 (binary search algorithm) 이 적용가능합니다.",
      "references": [
        {"[한] BST": "https://ko.wikipedia.org/wiki/%EC%9D%B4%EC%A7%84_%ED%83%90%EC%83%89_%ED%8A%B8%EB%A6%AC"},
        {"BST": "https://en.wikipedia.org/wiki/Binary_search_tree"},
        {"[한] Binary search algorithm": "https://ko.wikipedia.org/wiki/%EC%9D%B4%EC%A7%84_%EA%B2%80%EC%83%89_%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98"},
        {"Binary search algorithm": "https://en.wikipedia.org/wiki/Binary_search_algorithm"}
      ]
    }
  ]
}
