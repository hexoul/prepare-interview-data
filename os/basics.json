{
  "questions": [
    {
      "question": "운영체제란?",
      "choices": [
        "하드웨어 자원들을 관리하는 프로그램들의 집합",
        "응용프로그램들을 위한 System service provider",
        "하드웨어와 응용프로그램들을 이어주는 연결부",
        "위에 언급된 모두 해당"
      ],
      "answer": 4,
      "explanation": "운영체제란 하드웨어의 관리뿐만 아니라 응용 프로그램을 위한 서비스도 제공하는 시스템 소프트웨어입니다. 이 서비스를 통해 응용 프로그램은 하드웨어를 활용할 수 있습니다.",
      "references": [
        {"[한] OS": "https://ko.wikipedia.org/wiki/%EC%9A%B4%EC%98%81_%EC%B2%B4%EC%A0%9C"},
        {"OS": "https://en.wikipedia.org/wiki/Operating_system"}
      ]
    },
    {
      "question": "운영체제의 서비스에 접근하기위한 인터페이스는 ___를 통해 제공된다.",
      "choices": [
        "시스템 콜 (System call)",
        "API",
        "Library",
        "어셈블리 명령어 (Assembly instruction)"
      ],
      "answer": 1,
      "explanation": "-",
      "references": [{"System call": "https://en.wikipedia.org/wiki/System_call"}]
    },
    {
      "question": "커널 (Kernel) 에 대한 설명으로 틀린 것은?",
      "choices": [
        "Kernel은 운영체제의 핵심을 구성하는 프로그램이다.",
        "Kernel은 부팅하는 동안 메모리를 로드하는 운영체제의 첫 부분이다.",
        "Kernel은 운영체제를 실행하는 중에는 읽어들일 수 없는 다양한 모듈로 구성되어 있다.",
        "Kernel은 컴퓨터의 전체 세션동안 메모리에 남아있다."
      ],
      "answer": 3,
      "explanation": "커널은 운영체제의 핵심 부분으로 운영체제에 다양한 서비스를 지원하기위해 상호작용이 되어야하므로 지속적으로 읽어들일 수 있어야 합니다. 다만 커널은 강력한 권한을 가지기 때문에 보안을 위해 응용 프로그램이 접근할 수 없는 메모리 영역에서 보호됩니다.",
      "references": [
        {"[한] Kernel": "https://ko.wikipedia.org/wiki/%EC%BB%A4%EB%84%90_(%EC%BB%B4%ED%93%A8%ED%8C%85)"},
        {"Kernel": "https://en.wikipedia.org/wiki/Kernel_(operating_system)"}
      ]
    },
    {
      "question": "다음 중 어떤 것이 운영체제에 의해 처리되는 에러인가?",
      "choices": [
        "전력 문제",
        "프린터 용지 부족",
        "네트워크 연결 실패",
        "위에 언급된 모두 해당"
      ],
      "answer": 4,
      "explanation": "운영체제가 불러와진 뒤의 모든 환경은 운영체제의 관리 하에 있다고 볼 수 있습니다. 이는 소프트웨어뿐만 아니라 주변기기를 포함한 하드웨어도 해당합니다. 따라서 전력공급기의 전력 불안정, 프린터의 인쇄 완료 또는 용지 부족 등도 인지할 수 있습니다."
    },
    {
      "question": "명령 해석기 (Command interpreter) 의 주요 기능은?",
      "choices": [
        "사용자 정의 명령을 해석하고 실행하기 위함",
        "API와 응용프로그램 간의 인터페이스를 제공하기 위함",
        "운영체제에서 파일들을 처리하기 위함",
        "위에 언급된 모두 해당 안됨"
      ],
      "answer": 1,
      "explanation": "예시 : Bash (Unix의 shell), Z shell (Zsh) 등",
      "references": [
        {"Command interpreter": "https://en.wikipedia.org/wiki/List_of_command-line_interpreters"}
      ]
    },
    {
      "question": "운영체제의 자원은 ___으로 관리되어진다.",
      "choices": [
        "시분할 (Time division) multiplexing",
        "공간 분할 (Space division) multiplexing",
        "시공간 분할 (Time and space division) multiplexing",
        "위에 언급된 모두 해당 안됨"
      ],
      "answer": 3,
      "explanation": "\n- 시분할 multiplexing 예시 : single-core processor 상에서의 multiprogramming (CPU scheduling).\n- 공간 분할 multiplexing 예시 : memory 또는 disk. 하드웨어 자원을 여러 프로세스 또는 유저가 사용할 수 있도록 공간적으로 분리하는 것을 말합니다.",
      "references": [
        {"Multiplexing": "https://en.wikipedia.org/wiki/Multiplexing"}
      ]
    },
    {
      "question": "프로세스가 실패했을 때 대부분의 운영체제는 에러 정보를 ___에 기록한다.",
      "choices": [
        "로그 파일",
        "네트워크",
        "실행중인 다른 프로세스",
        "메모리"
      ],
      "answer": 1,
      "explanation": "에러 정보 (에러 로그)는 프로세스가 비정상적으로 종료되어도 확인할 수 있어야하므로 비휘발성인 저장소에 파일로 기록되는게 일반적입니다. 구현에 따라 추가적으로 네트워크를 통해 원격 저장소에 저장하기도 합니다."
    },
    {
      "question": "다음 중 실시간 운영체제가 아닌 것은?",
      "choices": [
        "VxWorks",
        "Windwos CE",
        "RTLinux",
        "Palm OS"
      ],
      "answer": 4,
      "explanation": "Palm OS는 96년도에 출시된 PDA 및 모바일용 운영체제로 터치스크린 GUI를 위해 개발되었고 실시간 운영체제는 아닙니다.",
      "references": [
        {"[한] Palm OS": "https://ko.wikipedia.org/wiki/%ED%8C%9C_OS"},
        {"Palm OS": "https://en.wikipedia.org/wiki/Palm_OS"}
      ]
    },
    {
      "question": "다음 중 커널 모드의 비중이 제일 큰 커널은?",
      "choices": [
        "Microkernel",
        "Monolithic kernel",
        "Hybrid kernel",
        "Exokernel"
      ],
      "answer": 2,
      "explanation": "\n커널 모드 비중 : Monolithic kernel > Hybrid kernel > Microkernel > Exokernel\n\n커널 모드란 커널, 커널 익스텐션 또는 디바이스 드라이버 등 시스템 레벨 소프트웨어가 권한을 받아 제약없이 코드를 실행할 수 있도록 예약된 공간을 뜻합니다. 커널 모드의 비중이 크다는 것은 커널이 많은 기능을 제공한다고 해석할 수 있습니다. 보기 중에서는 모놀리식 커널 (monolithic kernel) 의 커널 비중이 제일 높습니다. 단일형 커널이라 하여 운영체제의 거의 모든 기능이 단일 메모리 공간에서 실행됩니다.\n참고로 커널 모드는 커널 공간 (kernel space) 라고도 합니다.",
      "references": [
        {"Microkernel": "https://en.wikipedia.org/wiki/Microkernel"},
        {"Monolithic kernel": "https://en.wikipedia.org/wiki/Monolithic_kernel"},
        {"Hybrid kernel": "https://en.wikipedia.org/wiki/Hybrid_kernel"}
      ]
    },
    {
      "question": "컴퓨터가 전원을 공급받은 후 부트로더 (boot loader) 에 의해 실행되는 프로그램을 ___라 한다.",
      "choices": [
        "Boot program",
        "Setup program",
        "Initializer",
        "Bootstrap program"
      ],
      "answer": 4,
      "explanation": "전원을 공급받고 초기 설정을 하는 단계를 bootstrapping이라 합니다. 구체적으로 bootstrapping이란 하드웨어적으로 지정된 시작 주소에 있는 bootstrap progrm을 최초로 메인메모리로 읽어들여 외부 입력없이 추가적인 명령어를 읽어들일 수 있는 준비상태로 만드는 것까지를 말합니다. 준비상태를 만드는 것에는 설정 값과 BIOS를 불러오는 작업 등이 포함됩니다. 전형적으로 OS 초기화까지를 뜻합니다.\nBootstrapping을 줄여 booting이라고도 부르지만 일반적으로 bootstrap program은 boot program이라고 줄이지 않습니다.",
      "references": [
        {"Bootstrapping": "https://en.wikipedia.org/wiki/Bootstrapping#Computing"},
        {"Booting": "https://en.wikipedia.org/wiki/Booting"}
      ]
    },
    {
      "question": "소프트웨어는 어떻게 인터럽트 (interrupt) 를 발생시키는가?",
      "choices": [
        "버스를 통해 CPU에 시그널을 보낸다.",
        "인터럽트를 발생시키는 명령어를 직접 호출한다.",
        "시스템 콜을 통해 특별한 명령어를 수행한다.",
        "키보드 또는 마우스 입력을 통해 발생시킨다."
      ],
      "answer": 3,
      "explanation": "인터럽트는 수행되고 있는 프로세스들에 직접적으로 영향을 줄 수 있어, 운영체제 레벨에서 관리되도록 사용자가 직접 호출할 수 있는 방법은 제공하지않습니다. 시스템 콜을 통해서만 가능하도록 설계되어 있습니다.\nCPU가 버스를 통해 시그널을 받는 것은 하드웨어 인터럽트입니다. 키보드와 마우스 같은 외부 장치가 하드웨어 인터럽트를 발생시켜 프로세서에게 읽을 데이터가 있다고 알릴 수도 있습니다.",
      "references": [
        {"[한] Interrupt": "https://ko.wikipedia.org/wiki/%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8"},
        {"Software interrupt": "https://en.wikipedia.org/wiki/Interrupt#Software_interrupts"}
      ]
    },
    {
      "question": "트랩 (Trap) 이란?",
      "choices": [
        "에러에 의해 하드웨어로부터 발생된 인터럽트",
        "에러에 의해 소프트웨어로부터 발생된 인터럽트",
        "에러에 의해 유저로부터 발생된 인터럽트",
        "위에 언급된 모두 해당"
      ],
      "answer": 2,
      "explanation": "Exception 또는 fault라고도 불리는 trap은 프로세스의 예외적인 상황에서 발생하는 동기 인터럽트 (synchronous interrupt) 로 소프트웨어로부터 발생합니다. 일례로 디버깅에 사용되는 브레이크포인트 (breakpoint), 0으로 나누기 (division by zero) 또는 유효하지않은 메모리 접근이 있습니다.",
      "references": [
        {"[한] Trap": "https://ko.wikipedia.org/wiki/%ED%8A%B8%EB%9E%A9_(%EC%BB%B4%ED%93%A8%ED%8C%85)"},
        {"Trap": "https://en.wikipedia.org/wiki/Trap_(computing)"},
        {"Software interrupt": "https://en.wikipedia.org/wiki/Interrupt#Software_interrupts"},
        {"Exception": "https://en.wikipedia.org/wiki/Exception_handling"},
        {"[한] Breakpoint": "https://ko.wikipedia.org/wiki/%EB%B8%8C%EB%A0%88%EC%9D%B4%ED%81%AC%ED%8F%AC%EC%9D%B8%ED%8A%B8"},
        {"Breakpoint": "https://en.wikipedia.org/wiki/Breakpoint"}
      ]
    },
    {
      "question": "다음 중 interrupt handler라고도 불리는 ISR의 뜻으로 맞는 것은?",
      "choices": [
        "Information Service Request",
        "Interrupt Service Request",
        "Interrupt Service Routine",
        "Information Service Routine"
      ],
      "answer": 3,
      "explanation": "Interrupt가 발생했을 때 main routine에서 벗어나 interrupt의 종류에 따른 적절한 처리를 하고 복귀하기에 interrupt service routine이라 합니다.",
      "references": [
        {"[한] ISR": "https://ko.wikipedia.org/wiki/%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8_%ED%95%B8%EB%93%A4%EB%9F%AC"},
        {"ISR": "https://en.wikipedia.org/wiki/Interrupt_handler"}
      ]
    },
    {
      "question": "Interrupt vector란?",
      "choices": [
        "Interrupt handler를 가리키는 주소",
        "특정 주소와 연관된 고유 장치 번호",
        "Interrupt에 할당되는 고유 번호",
        "위에 언급된 모두 해당 안됨"
      ],
      "answer": 1,
      "explanation": "Interrupt vector란 인터럽트가 발생했을 때 수행되어야 할 interrupt handler 주소로 interrupt vector table에 모여 저장 및 관리됩니다.",
      "references": [
        {"[한] Interrupt vector table": "https://ko.wikipedia.org/wiki/%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8_%EB%B2%A1%ED%84%B0_%ED%85%8C%EC%9D%B4%EB%B8%94"},
        {"Interrupt vector table": "https://en.wikipedia.org/wiki/Interrupt_vector_table"}
      ]
    },
    {
      "question": "DMA는 ___를 위해 사용된다.",
      "choices": [
        "하드디스크",
        "그래픽카드",
        "멀티코어 프로세서",
        "위에 언급된 모두 해당"
      ],
      "answer": 4,
      "explanation": "Direct Memory Access (DMA) 는 CPU와는 독립적인 하드웨어를 통해 메모리에 직접 접근할 수 있도록 지원하는 기법입니다. 데이터 전송에 CPU의 개입이 불필요해 데이터 전송을 위해 읽고 쓰기를 하는 대신 다른 작업의 처리를 할 수 있게 되어 CPU 효율이 증가합니다. 멀티코어 프로세서 시스템에서 DMA는 프로세서 간의 데이터 전송을 지원하기도 합니다.",
      "references": [
        {"[한] DMA": "https://ko.wikipedia.org/wiki/%EC%A7%81%EC%A0%91_%EB%A9%94%EB%AA%A8%EB%A6%AC_%EC%A0%91%EA%B7%BC"},
        {"DMA": "https://en.wikipedia.org/wiki/Direct_memory_access"}
      ],
      "visible": false
    },
    {
      "question": "Memory-mapped I/O (MMIO) 에 대한 설명으로 맞는 것은?",
      "choices": [
        "입출력 장치가 데이터를 주고받을 준비되었는지 CPU가 지속적으로 polling하며 확인한다.",
        "입출력 장치와 메모리가 같은 주소 버스를 사용한다.",
        "입출력 장치가 데이터를 주고받을 준비가 되었을 때 CPU가 인터럽트를 받는다.",
        "CPU 외에 입출력 장치로부터 데이터를 읽어오기위한 장치가 있다."
      ],
      "answer": 2,
      "explanation": "MMIO란 메모리 공간 중 일부를 입출력 장치에 할당하여 쓰는 방식으로 일반 데이터를 읽고 쓰는 것처럼 I/O를 쓸 수 있습니다. 설계 관점에서 단순해지는 반면 I/O가 일반적으로 메모리 접근보다 느리기때문에 같은 주소 버스를 사용하게되는 메모리 접근이 영향을 받아 느려질 수 있습니다.",
      "references": [
        {"[한] MMIO": "https://ko.wikipedia.org/wiki/%EB%A9%94%EB%AA%A8%EB%A6%AC_%EB%A7%B5_%EC%9E%85%EC%B6%9C%EB%A0%A5"},
        {"MMIO": "https://en.wikipedia.org/wiki/Memory-mapped_I/O"}
      ],
      "visible": false
    },
    {
      "question": "Programmed I/O (PIO) 에 대한 설명으로 맞는 것은?",
      "choices": [
        "입출력 장치가 데이터를 주고받을 준비되었는지 CPU가 지속적으로 polling하며 확인한다.",
        "입출력 장치와 메모리가 같은 주소 버스를 사용한다.",
        "입출력 장치가 데이터를 주고받을 준비가 되었을 때 CPU가 인터럽트를 받는다.",
        "CPU 외에 입출력 장치로부터 데이터를 읽어오기위한 장치가 있다."
      ],
      "answer": 1,
      "explanation": "Programmed I/O 또는 polled I/O라 불리는 PIO는 입출력 장치와의 매 데이터 전송마다 CPU가 개입합니다.",
      "references": [
        {"[한] PIO": "https://ko.wikipedia.org/wiki/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8_%EC%9E%85%EC%B6%9C%EB%A0%A5"},
        {"PIO": "https://en.wikipedia.org/wiki/Programmed_input%E2%80%93output"},
        {"Polling": "https://en.wikipedia.org/wiki/Polling_(computer_science)"}
      ],
      "visible": false
    },
    {
      "question": "Interrupt-driven I/O에 대한 설명으로 맞는 것은?",
      "choices": [
        "입출력 장치가 데이터를 주고받을 준비되었는지 CPU가 지속적으로 polling하며 확인한다.",
        "입출력 장치와 메모리가 같은 주소 버스를 사용한다.",
        "입출력 장치가 데이터를 주고받을 준비가 되었을 때 CPU가 인터럽트를 받는다.",
        "CPU 외에 입출력 장치로부터 데이터를 읽어오기위한 장치가 있다."
      ],
      "answer": 3,
      "explanation": "-",
      "references": [
        {"Interrupt": "https://en.wikipedia.org/wiki/Interrupt"},
        {"Interrupt-driven I/O": "http://inputoutput5822.weebly.com/interrupt-driven-io.html"}
      ],
      "visible": false
    },
    {
      "question": "ISR 중 수행되는 동작은?",
      "choices": [
        "현재의 컨텍스트를 저장한다.",
        "인터럽트 벡터가 가리키는 코드를 읽고 실행한다.",
        "처리가 끝나면 인터럽트가 발생하기 전의 컨텍스트로 되돌린다.",
        "위에 언급된 모두 해당"
      ],
      "answer": 4,
      "explanation": "ISR은 Interrupt Service Routine으로 인터럽트가 발생했을 때 실행되는 일련의 과정입니다. 현재의 컨텍스트를 저장하고 발생한 인터럽트에 해당하는 인터럽트 벡터를 찾아 코드를 실행한 뒤 저장해두었던 컨텍스트를 복구시킵니다. 컨텍스트는 지역 변수 및 SP (stack pointer) 등을 포함합니다.",
      "references": [
        {"ISR": "https://en.wikipedia.org/wiki/Interrupt_handler"},
        {"Context switch": "https://en.wikipedia.org/wiki/Context_switch#Interrupt_handling"}
      ]
    },
    {
      "question": "다음에 실행될 명령어의 주소를 저장하고 있는 곳은?",
      "choices": [
        "CPU 범용 레지스터",
        "프로그램 카운터 (Program counter)",
        "프로세스의 스택",
        "파이프 (Pipe)"
      ],
      "answer": 2,
      "explanation": "프로그램 카운터도 CPU의 레지스터에 속하지만 범용이 아닌 특수 목적 레지스터입니다. 다양한 위치 또는 값을 저장하는 범용 레지스터와 달리 다음에 실행될 명령어의 주소만 저장합니다.",
      "references": [
        {"[한] Program counter": "https://ko.wikipedia.org/wiki/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8_%EC%B9%B4%EC%9A%B4%ED%84%B0"},
        {"Program counter" : "https://en.wikipedia.org/wiki/Program_counter"}
      ]
    },
    {
      "question": "DMA란?",
      "choices": [
        "Driving Memory Access",
        "Digital Memory Access",
        "Direct Memory Access",
        "Direct Memory Avoidance"
      ],
      "answer": 3,
      "explanation": "DMA란 Direct Memory Access로 CPU와는 독립적인 하드웨어를 통해 메모리에 직접 접근할 수 있도록 지원하는 기법입니다. 데이터 전송에 CPU의 개입이 불필요해 데이터 전송을 위해 읽고 쓰기를 하는 대신 다른 작업의 처리를 할 수 있게 되어 CPU 효율이 증가합니다.",
      "references": [
        {"[한] DMA": "https://ko.wikipedia.org/wiki/%EC%A7%81%EC%A0%91_%EB%A9%94%EB%AA%A8%EB%A6%AC_%EC%A0%91%EA%B7%BC"},
        {"DMA": "https://en.wikipedia.org/wiki/Direct_memory_access"}
      ]
    },
    {
      "question": "메모리를 특정 크기로 할당 및 해제할 때 공간 사용에 비효율이 생기는 것을 ___라 한다.",
      "choices": [
        "Fragmentation",
        "Defragmentation",
        "Blocking",
        "Caching"
      ],
      "answer": 1,
      "explanation": "단편화 (Fragmentation) 는 메모리의 할당과 해제가 계속하여 이루어지는 환경에서 발생하는 현상입니다. 공간이 할당되었는데도 불구하고 사용하지않는 공간이 있거나, 전체적으로는 빈 공간이 충분히 있음에도 불구하고 연속되어있지않아 사용할 수 없는 경우 등에서 공간이 낭비되는 것을 말합니다. 종류로는 내부 단편화, 외부 단편화 그리고 데이터 단편화가 있습니다.",
      "references": [
        {"[한] Fragmentation": "https://ko.wikipedia.org/wiki/%EB%8B%A8%ED%8E%B8%ED%99%94"},
        {"Fragmentation": "https://en.wikipedia.org/wiki/Fragmentation_(computing)"}
      ]
    },
    {
      "question": "외부 단편화에 대한 설명으로 맞는 것은?",
      "choices": [
        "메모리의 크기가 2의 배수가 아닐 때 발생한다.",
        "빈 공간이 쪼개져있어 제대로 사용하지 못하는 상황이다.",
        "용량이 큰 파일을 이동시킬 때 발생한다.",
        "실제 사용량보다 큰 크기의 영역이 할당되었을 때 발생한다."
      ],
      "answer": 2,
      "explanation": "빈 공간이 쪼개져있어 빈 공간의 합이 요청 크기보다 큼에도 불구하고 할당할 수 없거나 비효율적으로 할당하여 성능이 저하되는 상태를 외부 단편화 (external fragmentation) 라 합니다.",
      "references": [
        {"[한] Fragmentation": "https://ko.wikipedia.org/wiki/%EB%8B%A8%ED%8E%B8%ED%99%94"},
        {"Fragmentation": "https://en.wikipedia.org/wiki/Fragmentation_(computing)"}
      ]
    },
    {
      "question": "내부 단편화에 대한 설명으로 맞는 것은?",
      "choices": [
        "메모리의 크기가 2의 배수가 아닐 때 발생한다.",
        "빈 공간이 쪼개져있어 제대로 사용하지 못하는 상황이다.",
        "용량이 큰 파일을 이동시킬 때 발생한다.",
        "실제 사용량보다 큰 크기의 영역이 할당되었을 때 발생한다."
      ],
      "answer": 4,
      "explanation": "실제 사용량보다 큰 크기의 영역이 할당되어 사용하지않는 영역이 생기는 것을 내부 단편화 (internal fragmentation) 라 합니다.",
      "references": [
        {"[한] Fragmentation": "https://ko.wikipedia.org/wiki/%EB%8B%A8%ED%8E%B8%ED%99%94"},
        {"Fragmentation": "https://en.wikipedia.org/wiki/Fragmentation_(computing)"}
      ]
    },
    { 
      "question": "Inter-process communication (IPC) 란?",
      "choices": [
        "같은 주소 공간을 사용하는 프로세스 간의 통신",
        "같은 주소 공간을 사용하지않는 프로세스 간의 통신",
        "네트워크를 통한 프로세스 간의 통신",
        "통신이 필요없는 프로세스 간 동기화 기법"
      ],
      "answer": 2,
      "explanation": "보기 (1)은 전제부터 성립할 수 없습니다. 운영체제 하에서 주소 공간은 프로세스 별로 관리됩니다.\nIPC는 프로세스 간에 데이터를 공유하기위해 통신을 가능하게 만드는 메커니즘으로, 이는 파일, 소켓, 메시지 큐 등을 통해 다양하게 구현될 수 있습니다. 따라서 네트워크를 통하는 것만이라고 한정지을 수 없기 때문에 보기 (4)도 옳지 않습니다.",
      "references": [
        {"[한] IPC": "https://ko.wikipedia.org/wiki/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4_%EA%B0%84_%ED%86%B5%EC%8B%A0"},
        {"IPC": "https://en.wikipedia.org/wiki/Inter-process_communication"}
      ]
    },
    {
      "question": "IPC 시 프로세스가 보내는 메세지의 크기는 ___",
      "choices": [
        "고정되어야 한다.",
        "가변이어야 한다.",
        "고정일 수도 있고 가변일 수도 있다.",
        "운영체제마다 다르다."
      ],
      "answer": 3,
      "explanation": "메시지 크기는 고정과 가변 둘 다 가능하며 각각 장단점이 있습니다. 고정일 경우 OS 설계자 입장에서는 구현이 간단해지지만 애플리케이션 개발자 입장에서는 구현이 복잡해질 수 있습니다. 반대로 가변일 경우 OS 설계자 입장에서는 복잡해지지만 애플리케이션 개발자는 보다 쉽게 개발할 수 있는 여지가 생깁니다.\n\n결과적으로 고정과 가변을 모두 제공하기 위해서 표준 메시지는 고정된 크기의 header와 가변 body를 가집니다. Header에 메시지 제어를 위한 정보와 함께 길이 정보도 있어, 운영체제는 이에 기반하여 body 범위를 인지하고 얻어올 수 있습니다.",
      "references": [
        {"[한] Message passing": "https://ko.wikipedia.org/wiki/%EB%A9%94%EC%8B%9C%EC%A7%80_%EC%A0%84%EB%8B%AC_%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4"},
        {"Message passing": "https://www.geeksforgeeks.org/inter-process-communication-ipc"}
      ]
    },
    {
      "question": "메시지를 보내고 받기 위한 두 프로세스 간의 링크를 ___라 한다.",
      "choices": [
        "Communication link",
        "Message-passing link",
        "Synchronization link",
        "Process link"
      ],
      "answer": 1,
      "explanation": "-",
      "references": [
        {"Communication link": "https://www.geeksforgeeks.org/inter-process-communication-ipc"}
      ]
    },
    {
      "question": "물리 메모리 (Physical memory) 에서 고정된 크기의 연속된 블록들을 ___라고 한다.",
      "choices": [
        "Storage",
        "Frame",
        "Page",
        "Row"
      ],
      "answer": 2,
      "explanation": "물리 메모리에서 프레임 (frame) 은 2의 거듭제곱만큼 고정된 크기로 운영체제마다 다를 수 있습니다. e.g. 512 bytes 또는 1,024 bytes 등.\n따라서 프레임의 크기에 따라 한 프레임에 포함되는 블록의 개수 도 바뀝니다. 블록의 크기는 프로세서의 하드웨어 스펙 및 ISA (Instruction Set Architecture) 로부터 결정됩니다.",
      "references": [
        {"Primary storage": "https://en.wikipedia.org/wiki/Computer_data_storage#Primary_storage"}
      ]
    },
    {
      "question": "가상 메모리 (Virtual memory) 에서 고정된 크기의 연속된 블록들을 ___라고 한다.",
      "choices": [
        "Storage",
        "Frame",
        "Page",
        "Row"
      ],
      "answer": 3,
      "explanation": "가상 메모리에서 물리 메모리의 프레임 (frame) 에 해당하는 것이 페이지 (page) 입니다. 일반적으로 프레임과 페이지의 크기는 동일합니다. 다만 가상 메모리 특성 상 페이지의 순서는 프레임의 순서와 상관없으며, 서로 다른 페이지가 동일한 프레임을 가리킬 수 있습니다.",
      "references": [
        {"[한] Virtual memory": "https://ko.wikipedia.org/wiki/%EA%B0%80%EC%83%81_%EB%A9%94%EB%AA%A8%EB%A6%AC"},
        {"Virtual memory": "https://en.wikipedia.org/wiki/Virtual_memory"}
      ]
    }
  ]
}
