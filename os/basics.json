{
  "questions": [
    {
      "question": "운영체제란?",
      "choices": [
        "하드웨어 자원들을 관리하는 프로그램들의 집합",
        "응용프로그램들을 위한 System service provider",
        "하드웨어와 응용프로그램들을 이어주는 연결부",
        "위에 언급된 모두 해당"
      ],
      "answer": 4,
      "explanation": "-",
      "references": [
        {"[한]OS": "https://ko.wikipedia.org/wiki/%EC%9A%B4%EC%98%81_%EC%B2%B4%EC%A0%9C"},
        {"OS": "https://en.wikipedia.org/wiki/Operating_system"}
      ]
    },
    {
      "question": "운영체제의 서비스에 접근하기위한 인터페이스는 ___를 통해 제공된다.",
      "choices": [
        "시스템 콜 (System call)",
        "API",
        "Library",
        "어셈블리 명령어 (Assembly instruction)"
      ],
      "answer": 1,
      "explanation": "-",
      "references": [{"System call": "https://en.wikipedia.org/wiki/System_call"}]
    },
    {
      "question": "다음 중 틀린 설명은?",
      "choices": [
        "Kernel은 운영체제의 핵심을 구성하는 프로그램이다.",
        "Kernel은 부팅하는 동안 메모리를 로드하는 운영체제의 첫 부분이다.",
        "Kernel은 운영체제를 실행하는 중에는 읽어들일 수 없는 다양한 모듈로 구성되어 있다.",
        "Kernel은 컴퓨터의 전체 세션동안 메모리에 남아있다."
      ],
      "answer": 3,
      "explanation": "Kernel은 운영체제의 핵심 부분으로 운영체제에 다양한 서비스를 지원하기위해 상호작용이 되어야하므로 읽어들일 수 있어야 합니다.",
      "references": [
        {"커널": "https://ko.wikipedia.org/wiki/%EC%BB%A4%EB%84%90_(%EC%BB%B4%ED%93%A8%ED%8C%85)"},
        {"Kernel": "https://en.wikipedia.org/wiki/Kernel_(operating_system)"}
      ]
    },
    {
      "question": "다음 중 어떤 것이 운영체제에 의해 처리되는 에러인가?",
      "choices": [
        "정전, 전력 문제",
        "프린터 용지 부족",
        "네트워크 연결 실패",
        "위에 언급된 모두 해당"
      ],
      "answer": 4,
      "explanation": "운영체제가 불러와진 뒤의 모든 환경은 운영체제의 관리 하에 있다고 볼 수 있습니다. 이는 SW뿐만 아니라 HW도 해당합니다."
    },
    {
      "question": "명령 해석기 (Command interpreter) 의 주요 기능은?",
      "choices": [
        "사용자 정의 명령을 해석하고 실행하기 위함",
        "API와 응용프로그램 간의 인터페이스를 제공하기 위함",
        "운영체제에서 파일들을 처리하기 위함",
        "모두 해당 안됨"
      ],
      "answer": 1,
      "explanation": "예시 - Bash (Unix의 shell), Z shell (Zsh) 등",
      "references": [{"Command interpreter" : "https://en.wikipedia.org/wiki/List_of_command-line_interpreters"}]
    },
    {
      "question": "운영체제의 자원은 ___을 통해 관리되어진다.",
      "choices": [
        "시분할 (Time division) multiplexing",
        "공간 분할 (Space division) multiplexing",
        "시공간 분할 (Time and space division) multiplexing",
        "모두 해당 안됨"
      ],
      "answer": 3,
      "explanation": "\n* 시분할 multiplexing 예시 : Single-core processor 상에서의 multiprogramming (CPU scheduling).\n\n* 공간 분할 multiplexing 예시 : Process Control Block (PCB)"
    },
    {
      "question": "프로세스가 실패했을 때 대부분의 운영체제는 에러 정보를 ___에 기록한다.",
      "choices": [
        "로그 파일",
        "네트워크",
        "실행중인 다른 프로세스",
        "메모리"
      ],
      "answer": 1,
      "explanation": "에러 정보 (에러 로그)는 프로세스가 비정상적으로 종료되어도 확인할 수 있어야하므로 비휘발성인 저장소에 파일로 기록되는게 일반적입니다. 구현에 따라 추가적으로 네트워크를 통해 원격 저장소에 저장하기도 합니다."
    },
    {
      "question": "다음 중 실시간 운영체제가 아닌 것은?",
      "choices": [
        "VxWorks",
        "Windwos CE",
        "RTLinux",
        "Palm OS"
      ],
      "answer": 4,
      "explanation": "Palm OS는 96년도에 출시된 PDA 및 모바일용 운영체제로 터치스크린 GUI를 위해 개발되었고 실시간 운영체제는 아닙니다.",
      "references": [
        {"[한]Palm OS": "https://ko.wikipedia.org/wiki/%ED%8C%9C_OS"},
        {"Palm OS" : "https://en.wikipedia.org/wiki/Palm_OS"}
      ]
    },
    {
      "question": "다음 중 Kernel mode (Kernel space)의 비중이 제일 큰 kernel은?",
      "choices": [
        "Microkernel",
        "Monolithic kernel",
        "Hybrid kernel",
        "Exokernel"
      ],
      "answer": 2,
      "explanation": "\nKernel space 크기 : Monolithic kernel > Hybrid kernel > Microkernel > Exokernel",
      "references": [
        {"Microkernel" : "https://en.wikipedia.org/wiki/Microkernel"},
        {"Monolithic kernel" : "https://en.wikipedia.org/wiki/Monolithic_kernel"},
        {"Hybrid kernel" : "https://en.wikipedia.org/wiki/Hybrid_kernel"}
      ]
    },
    {
      "question": "컴퓨터가 전원을 공급받았을 때 최초로 실행되는 프로그램을 ___라 한다.",
      "choices": [
        "Boot program",
        "Bootloader",
        "Initializer",
        "Bootstrap program"
      ],
      "answer": 4,
      "explanation": "전원을 공급받고 초기 설정을 하는 단계를 bootstrapping이라 합니다. 구체적으로 bootstrapping이란 하드웨어적으로 지정된 시작 주소에 있는 bootstrap progrm을 최초로 메인메모리로 읽어들여 외부 입력없이 추가적인 명령어를 읽어들일 수 있는 준비상태로 만드는 것까지를 말합니다. 준비상태를 만드는 것에는 설정 값과 BIOS를 불러오는 작업 등이 포함됩니다. Bootstrapping을 줄여 booting이라고도 부르지만 bootstrap program은 boot program이라고 줄이지 않습니다.",
      "references": [
        {"Bootstrapping" : "https://en.wikipedia.org/wiki/Bootstrapping#Computing"}
      ]
    },
    {
      "question": "소프트웨어는 어떻게 인터럽트 (interrupt) 를 촉발 (trigger) 시키는가?",
      "choices": [
        "버스를 통해 CPU에 시그널을 보낸다.",
        "Interrupt triggering instruction을 직접 호출한다.",
        "시스템 콜을 통해 특별한 명령어를 수행한다.",
        "시스템 프로그램을 통해 특별한 프로그램을 수행한다."
      ],
      "answer": 3,
      "explanation": "Interrupt는 수행되고 있는 프로세스들에 직접적으로 영향을 줄 수 있어, 운영체제 레벨에서 관리되도록 사용자가 직접 호출할 수 있는 방법은 제공하지않습니다. 시스템 콜을 통해서만 가능하도록 설계되어 있습니다. 시스템 콜을 통해 특정 한 명령어가 실행되는 것으로 명령어들의 집합이 아니기에 프로그램은 잘못된 설명입니다.",
      "references": [
        {"Software interrupt" : "https://en.wikipedia.org/wiki/Interrupt#Software_interrupts"}
      ]
    },
    {
      "question": "Trap 또는 exception에 대한 설명은?",
      "choices": [
        "에러에 의해 하드웨어로부터 발생된 인터럽트",
        "에러에 의해 소프트웨어로부터 발생된 인터럽트",
        "에러에 의해 유저로부터 발생된 인터럽트",
        "위에 언급된 모두 해당"
      ],
      "answer": 2,
      "explanation": "Exception 또는 fault라고도 불리는 trap은 프로세스의 예외적인 상황에서 발생하는 동기 인터럽트 (synchronous interrupt) 로 소프트웨어로부터 발생합니다. 예로 breakpoint, 0으로 나누기 (division by zero) 또는 유효하지않은 메모리에의 접근이 있습니다.",
      "references": [
        {"Software interrupt" : "https://en.wikipedia.org/wiki/Interrupt#Software_interrupts"},
        {"Trap": "https://en.wikipedia.org/wiki/Trap_(computing)"},
        {"Exception": "https://en.wikipedia.org/wiki/Exception_handling"}
      ]
    },
    {
      "question": "다음 중 interrupt handler라고도 불리는 ISR의 뜻으로 맞는 것은?",
      "choices": [
        "Information Service Request",
        "Interrupt Service Request",
        "Interrupt Service Routine",
        "Information Service Routine"
      ],
      "answer": 3,
      "explanation": "Interrupt가 발생했을 때 main routine에서 벗어나 interrupt의 종류에 따른 적절한 처리를 하고 복귀하기에 interrupt service routine이라 합니다.",
      "references": [
        {"ISR" : "https://en.wikipedia.org/wiki/Interrupt_handler"}
      ]
    },
    {
      "question": "Interrupt vector란?",
      "choices": [
        "Interrupt handler를 가리키는 주소",
        "특정 주소와 연관된 고유 장치 번호",
        "Interrupt에 할당되는 고유 번호",
        "위에 언급된 모두 해당 안됨"
      ],
      "answer": 1,
      "explanation": "Interrupt vector란 인터럽트가 발생했을 때 수행되어야 할 interrupt handler 주소로 interrupt vector table에 모여 저장 및 관리됩니다.",
      "references": [
        {"Interrupt vector table" : "https://en.wikipedia.org/wiki/Interrupt_vector_table"}
      ]
    },
    {
      "question": "DMA는 ___를 위해 사용된다.",
      "choices": [
        "하드디스크",
        "그래픽카드",
        "멀티코어 프로세서",
        "위에 언급된 모두 해당"
      ],
      "answer": 4,
      "explanation": "Direct Memory Access (DMA) 는 CPU와는 독립적인 하드웨어를 통해 메모리에 직접 접근할 수 있도록 지원하는 기법입니다. 데이터 전송에 CPU의 개입이 불필요해 데이터 전송을 위해 읽고 쓰기를 하는 대신 다른 작업의 처리를 할 수 있게 되어 CPU 효율이 증가합니다.",
      "references": [
        {"[한] DMA": "https://ko.wikipedia.org/wiki/%EC%A7%81%EC%A0%91_%EB%A9%94%EB%AA%A8%EB%A6%AC_%EC%A0%91%EA%B7%BC"},
        {"DMA" : "https://en.wikipedia.org/wiki/Direct_memory_access"}
      ]
    },
    {
      "question": "Memory-mapped I/O (MMIO) 에 대한 설명으로 맞는 것은?",
      "choices": [
        "입출력 장치가 데이터를 주고받을 준비되었는지 CPU가 지속적으로 polling하며 확인한다.",
        "입출력 장치와 메모리가 같은 주소 버스를 사용한다.",
        "입출력 장치가 데이터를 주고받을 준비가 되었을 때 CPU가 인터럽트를 받는다.",
        "CPU 외에 입출력 장치로부터 데이터를 읽어오기위한 장치가 있다."
      ],
      "answer": 2,
      "explanation": "MMIO란 메모리 공간 중 일부를 입출력 장치에 할당하여 쓰는 방식으로 일반 데이터를 읽고 쓰는 것처럼 I/O를 쓸 수 있습니다. 설계 관점에서 단순해지는 반면 I/O가 일반적으로 메모리 접근보다 느리기때문에 같은 주소 버스를 사용하게되는 메모리 접근이 영향을 받아 느려질 수 있습니다.",
      "references": [
        {"[한] MMIO" : "https://ko.wikipedia.org/wiki/%EB%A9%94%EB%AA%A8%EB%A6%AC_%EB%A7%B5_%EC%9E%85%EC%B6%9C%EB%A0%A5"},
        {"MMIO" : "https://en.wikipedia.org/wiki/Memory-mapped_I/O"}
      ]
    },
    {
      "question": "Programmed I/O (PIO) 에 대한 설명으로 맞는 것은?",
      "choices": [
        "입출력 장치가 데이터를 주고받을 준비되었는지 CPU가 지속적으로 polling하며 확인한다.",
        "입출력 장치와 메모리가 같은 주소 버스를 사용한다.",
        "입출력 장치가 데이터를 주고받을 준비가 되었을 때 CPU가 인터럽트를 받는다.",
        "CPU 외에 입출력 장치로부터 데이터를 읽어오기위한 장치가 있다."
      ],
      "answer": 1,
      "explanation": "Programmed I/O 또는 polled I/O라 불리는 PIO는 입출력 장치와의 매 데이터 전송마다 CPU가 개입합니다.",
      "references": [
        {"Polling": "https://en.wikipedia.org/wiki/Polling_(computer_science)"},
        {"[한] PIO" : "https://ko.wikipedia.org/wiki/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8_%EC%9E%85%EC%B6%9C%EB%A0%A5"},
        {"PIO" : "https://en.wikipedia.org/wiki/Programmed_input%E2%80%93output"}
      ]
    },
    {
      "question": "Interrupt-driven I/O에 대한 설명으로 맞는 것은?",
      "choices": [
        "입출력 장치가 데이터를 주고받을 준비되었는지 CPU가 지속적으로 polling하며 확인한다.",
        "입출력 장치와 메모리가 같은 주소 버스를 사용한다.",
        "입출력 장치가 데이터를 주고받을 준비가 되었을 때 CPU가 인터럽트를 받는다.",
        "CPU 외에 입출력 장치로부터 데이터를 읽어오기위한 장치가 있다."
      ],
      "answer": 3,
      "explanation": "-",
      "references": [
        {"Interrupt" : "https://en.wikipedia.org/wiki/Interrupt"},
        {"Interrupt-driven I/O" : "http://inputoutput5822.weebly.com/interrupt-driven-io.html"}
      ]
    },
    {
      "question": "Interrupt handler (ISR)에 의해 수행되는 동작은?",
      "choices": [
        "현재의 컨텍스트를 저장한다.",
        "Interrupt vector에 저장된 코드를 읽고 실행한다.",
        "Handling이 끝나면 인터럽트가 발생하기 전의 컨텍스트로 되돌린다.",
        "위에 언급된 모두 해당"
      ],
      "answer": 4,
      "explanation": "-",
      "references": [
        {"ISR" : "https://en.wikipedia.org/wiki/Interrupt_handler"},
        {"Context switch": "https://en.wikipedia.org/wiki/Context_switch#Interrupt_handling"}
      ]
    }
  ]
}
