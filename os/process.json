{
  "questions": [
    {
      "question": "한 번에 하나의 프로세스의 실행만 허용하는 시스템을 ___라 부른다.",
      "choices": [
        "Uniprogramming system",
        "Uniprocessor system",
        "Unitasking system",
        "Universal system"
      ],
      "answer": 2,
      "explanation": "한 개의 프로세서를 뜻하는 Uniprocessor가 정답입니다. Uniprogramming system은 한 번에 하나의 프로그램에 대한 메모리만 로드할 수 있는 시스템입니다. 하나의 프로세서로도 한 번에 하나 이상의 프로그램들을 실행가능하게 만드는 시스템은 multiprogramming system이라 합니다.",
      "references": [
        {"Uniprocessor system": "https://en.wikipedia.org/wiki/Uniprocessor_system"}
      ]
    },
    {
      "question": "운영체제에서 각 프로세스는 자신의 ___를 가진다.",
      "choices": [
        "프로세스 상태",
        "프로그램 카운터",
        "프로세스에서 연 파일들에 대한 정보",
        "위에 언급된 모두 해당"
      ],
      "answer": 4,
      "explanation": "여러 프로세스가 전환되어가며 실행될 수 있기때문에, 프로세스마다 서로 다른 실행 환경을 각자 저장하고 있습니다. 저장하는 구조체의 이름을 Process Control Block (PCB) 라고 합니다. PCB에는 프로세스 상태, 프로그램 카운터, 범용 레지스터, 프로세스에서 연 파일들에 대한 정보 그리고 시그널 핸들러 등을 포함합니다.",
      "references": [
        {"[한] PCB": "https://ko.wikipedia.org/wiki/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4_%EC%A0%9C%EC%96%B4_%EB%B8%94%EB%A1%9D"},
        {"PCB": "https://en.wikipedia.org/wiki/Process_control_block"}
      ]
    },
    {
      "question": "Unix에서 새로운 프로세스를 만드는 시스템 콜은 무엇인가?",
      "choices": [
        "fork",
        "create",
        "new",
        "모두 해당 안됨"
      ],
      "answer": 1,
      "explanation": "-",
      "references": [
        {"fork": "https://en.wikipedia.org/wiki/Fork_(system_call)"}
      ]
    },
    {
      "question": "프로세스는 ___에 의해 종료될 수 있다.",
      "choices": [
        "Normal exit",
        "Fatal error",
        "다른 프로세스",
        "위에 언급된 모두 해당"
      ],
      "answer": 4,
      "explanation": "-",
      "references": [
        {"[한] Process": "https://ko.wikipedia.org/wiki/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4"},
        {"Process": "https://en.wikipedia.org/wiki/Process_(computing)"}
      ]
    },
    {
      "question": "프로세스의 상태 (state) 중 Ready에 해당하는 것은?",
      "choices": [
        "실행 후 다음 실행을 위해 스케줄 된 상태",
        "어떤 Task가 완료될 때까지 실행할 수 없는 상태",
        "CPU를 사용하고 있는 상태",
        "모두 해당 안됨"
      ],
      "answer": 1,
      "explanation": "(2)는 Blocked에 대한 설명이며 (3)은 Running에 대한 설명입니다.",
      "references": [
        {"[한] Process state": "https://ko.wikipedia.org/wiki/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4#%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%9D%98_%EC%83%81%ED%83%9C"},
        {"Process state" : "https://en.wikipedia.org/wiki/Process_state"}
      ]
    },
    {
      "question": "Inter-process communication 이란?",
      "choices": [
        "프로세스 내부의 통신",
        "두 프로세스 간의 통신",
        "같은 프로세스에 속하는 두 쓰레드 간의 통신",
        "모두 해당 안됨"
      ],
      "answer": 2,
      "explanation": "-",
      "references": [
        {"[한] IPC": "https://ko.wikipedia.org/wiki/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4_%EA%B0%84_%ED%86%B5%EC%8B%A0"},
        {"IPC" : "https://en.wikipedia.org/wiki/Inter-process_communication"}
      ]
    },
    {
      "question": "프로세스의 교착 상태 (deadlock) 조건에 해당하지 않는 경우는?",
      "choices": [
        "상호배제 (Mutual exclusion)",
        "점유대기 (Hold and wait)",
        "선점 (Preemption)",
        "순환대기 (Circular wait)"
      ],
      "answer": 3,
      "explanation": "Deadlock의 조건에 해당하는 것은 선점이 아니라 비선점 (No preemption) 입니다. 비선점일 경우 자원 소유자 외에는 자원을 해제할 수 없습니다.\n네 개의 교착 상태 조건은 필요충분조건으로 조건을 모두 만족할 때 교착 상태가 발생합니다. 참고로 발의자의 이름을 따서 코프먼 조건이라고도 합니다.",
      "references": [
        {"[한] Deadlock": "https://ko.wikipedia.org/wiki/%EA%B5%90%EC%B0%A9_%EC%83%81%ED%83%9C"},
        {"Deadlock" : "https://en.wikipedia.org/wiki/Deadlock"}
      ]
    },
    {
      "question": "프로세스의 스택 (Stack) 이 포함하지 않는 것은?",
      "choices": [
        "함수 매개변수 (Function parameters)",
        "지역 변수 (Local variables)",
        "복귀 주소 (Return addresses)",
        "자식 프로세스의 PID"
      ],
      "answer": 4,
      "explanation": "-",
      "references": [
        {"[한] Call stack": "https://ko.wikipedia.org/wiki/%EC%BD%9C_%EC%8A%A4%ED%83%9D"},
        {"Call stack" : "https://en.wikipedia.org/wiki/Call_stack"}
      ]
    },
    {
      "question": "종료된 자식 프로세스의 정보를 얻어올 수 있는 system call은?",
      "choices": [
        "wait",
        "exit",
        "fork",
        "get"
      ],
      "answer": 1,
      "explanation": "-",
      "references": [
        {"wait" : "https://en.wikipedia.org/wiki/Wait_(system_call)"},
        {"exit" : "https://en.wikipedia.org/wiki/Exit_(system_call)"},
        {"fork" : "https://en.wikipedia.org/wiki/Fork_(system_call)"}
      ]
    },
    {
      "question": "다음에 실행될 명령어의 주소를 저장하고 있는 곳은?",
      "choices": [
        "CPU registers",
        "Program counter",
        "Process stack",
        "Pipe"
      ],
      "answer": 2,
      "explanation": "-",
      "references": [
        {"[한] Program counter": "https://ko.wikipedia.org/wiki/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8_%EC%B9%B4%EC%9A%B4%ED%84%B0"},
        {"Program counter" : "https://en.wikipedia.org/wiki/Program_counter"}
      ]
    },
    {
      "question": "Process Control Block (PCB) 에 포함되지 않는 것은?",
      "choices": [
        "Code",
        "Stack",
        "Bootstrap program",
        "Data"
      ],
      "answer": 3,
      "explanation": "-",
      "references": [
        {"[한] PCB": "https://ko.wikipedia.org/wiki/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4_%EC%A0%9C%EC%96%B4_%EB%B8%94%EB%A1%9D"},
        {"PCB": "https://en.wikipedia.org/wiki/Process_control_block"}
      ]
    },
    {
      "question": "단위 시간동안 완료된 프로세스의 수를 ___라 한다.",
      "choices": [
        "Output",
        "Throughput",
        "Efficiency",
        "Capacity"
      ],
      "answer": 2,
      "explanation": "-",
      "references": [
        {"Throughput and Capacity": "https://www.weibull.com/hotwire/issue27/relbasics27.htm"}
      ]
    },
    {
      "question": "프로세스의 상태 (state) 는 ___에 의해 정의된다.",
      "choices": [
        "프로세스의 최종 활동",
        "프로세스가 막 실행한 활동",
        "프로세스가 다음에 실행할 활동",
        "프로세스의 현재 활동"
      ],
      "answer": 4,
      "explanation": "-",
      "references": [
        {"[한] Process state": "https://ko.wikipedia.org/wiki/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4#%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%9D%98_%EC%83%81%ED%83%9C"},
        {"Process state": "https://en.wikipedia.org/wiki/Process_state"}
      ]
    },
    {
      "question": "다음 중 프로세스의 상태 (state) 가 아닌 것은?",
      "choices": [
        "New",
        "Old",
        "Waiting",
        "Running"
      ],
      "answer": 2,
      "explanation": "New 또는 created는 생성 직후의 상태입니다. Running은 실행 중인 상태, waiting은 실행되지않고 I/O 등의 인터럽트를 기다리고 있는 상태입니다. 완료 시 terminated 상태가 되며 old 상태는 없습니다.",
      "references": [
        {"[한] Process state": "https://ko.wikipedia.org/wiki/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4#%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%9D%98_%EC%83%81%ED%83%9C"},
        {"Process state": "https://en.wikipedia.org/wiki/Process_state"}
      ]
    },
    {
      "question": "Process Control Block (PCB) 이란?",
      "choices": [
        "프로세스 타입 변수",
        "자료 구조",
        "보조 기억장치의 일부",
        "메모리 블럭"
      ],
      "answer": 2,
      "explanation": "-",
      "references": [
        {"[한] PCB": "https://ko.wikipedia.org/wiki/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4_%EC%A0%9C%EC%96%B4_%EB%B8%94%EB%A1%9D"},
        {"PCB": "https://en.wikipedia.org/wiki/Process_control_block"}
      ]
    },
    {
      "question": "모든 PCB들은 ___에 속하여 관리되어진다.",
      "choices": [
        "Process Register",
        "Program Counter",
        "Process Table",
        "Process Unit"
      ],
      "answer": 3,
      "explanation": "-",
      "references": [
        {"[한] PCB": "https://ko.wikipedia.org/wiki/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4_%EC%A0%9C%EC%96%B4_%EB%B8%94%EB%A1%9D"},
        {"Process table and PCB": "https://www.geeksforgeeks.org/process-table-and-process-control-block-pcb/"}
      ]
    },
    {
      "question": "다중 프로그래밍의 정도 (the degree of multiprogramming) 를 판단할 수 있는 요소는?",
      "choices": [
        "단위 시간 내에 실행된 프로세스의 수",
        "Ready queue에 존재하는 프로세스의 수",
        "Waiting queue에 존재하는 프로세스의 수",
        "메모리에 존재하는 프로세스의 수"
      ],
      "answer": 4,
      "explanation": "다중 프로그래밍의 정도란 한 프로세서가 얼마나 많은 프로그램을 수행할 수 있는지로 볼 수 있습니다. 우선 단위 시간 내에 실행된 수는 적절하지 않습니다. 왜냐하면 다중 프로그래밍의 정도가 높더라도 실제 실행된 프로세스의 수는 적을 수도 있기 때문입니다. 예를 들어 대부분의 프로세스가 I/O 응답을 기다리고 있었다면, 역량이 되는데도 불구하고 동시에 실행되는 프로세스의 수는 적을 수 있습니다.\n프로세스가 메모리에 적재되었다는 것은 다중 프로그래밍의 대상이 될 수 있다는 얘기이므로 (4)가 정답입니다. Ready queue 또는 waiting queue 둘 중 하나가 아닌 전부 고려되어야 합니다.\n이외에 the degree of multiprogramming에 영향을 주는 요소로 예시에서 잠깐 얘기했던 I/O bound 또는 CPU bound, 메모리의 접근 속도 등이 있습니다.",
      "references": [
        {"The degree of multiprogramming": "https://owd.tcnj.edu/~coburn/os"},
        {"[한] Multiprogramming": "https://ko.wikipedia.org/wiki/%EB%8B%A4%EC%A4%91_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D"},
        {"Multiprogramming": "https://en.wikipedia.org/wiki/Computer_multitasking#Multiprogramming"}
      ]
    },
    {
      "question": "싱글 쓰레드는 프로세스가 ___를 처리할 수 있게 한다.",
      "choices": [
        "한 번에 하나의 태스크 (task)",
        "한 번에 복수의 태스크 (task)",
        "한 번에 두 태스크 (task)",
        "모두 해당 안됨"
      ],
      "answer": 1,
      "explanation": "태스크는 작업 단위를 의미합니다.",
      "references": [
        {"[한] Task": "https://ko.wikipedia.org/wiki/%ED%83%9C%EC%8A%A4%ED%81%AC"},
        {"Task": "https://en.wikipedia.org/wiki/Task_(computing)"}
      ]
    },
    {
      "question": "멀티프로그래밍 (Multiprogramming) 의 목적은?",
      "choices": [
        "프로세스들을 항상 실행시키기 위함",
        "Queue에 대기하고있는 복수의 프로그램들을 실행시킬 준비를 하기 위함",
        "CPU 활용도를 최소화하기 위함",
        "모두 해당 안됨"
      ],
      "answer": 1,
      "explanation": "단일 프로그램만 수행할 경우 I/O가 있을 때 프로그램 수행을 멈추고 인터럽트를 기다려야해서 대기하는 동안 CPU를 활용하지 못하는 비효율이 발생합니다. 이에 대기하는 시간에 다른 프로그램을 실행시켜 CPU 활용효율을 개선하고자 제안된 것이 multiprogramming 입니다.",
      "references": [
        {"[한] Multiprogramming": "https://ko.wikipedia.org/wiki/%EB%8B%A4%EC%A4%91_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D"},
        {"Multiprogramming": "https://en.wikipedia.org/wiki/Computer_multitasking"}
      ]
    }
  ]
}
