{
  "questions": [
    {
      "question": "운영체제가 얼마나 많은 프로세스가 동시에 가지고 있는 지와 상관없이 각 프로세스에게 충분한 공간을 가졌다는 추상화를 제공하기 위해 어떤 기법을 사용한다. 이때 쓰이는 주소를 ___라 한다.",
      "choices": [
        "실주소 (Real address)",
        "물리 주소 (Physical address)",
        "가상 주소 (Virtual address)",
        "이진 주소 (Binary address)"
      ],
      "answer": 3,
      "explanation": "가상 주소를 통해 실제 물리 공간보다 큰 추상화된 공간을 각 프로세스에 제공할 수 있습니다. 여기서 각 프로세스는 물리 주소가 아니라 가상 주소를 통해서 데이터를 읽고 쓸 수 있습니다.\n물리 주소는 실주소 또는 이진주소라고도 하며, 가상 주소는 논리 주소 (logical address) 라고도 합니다.",
      "references": [
        {"[한] Virtual address": "https://ko.wikipedia.org/wiki/%EA%B0%80%EC%83%81_%EC%A3%BC%EC%86%8C_%EA%B3%B5%EA%B0%84"},
        {"Virtual address": "https://en.wikipedia.org/wiki/Virtual_address_space"},
        {"[한] Physical address": "https://ko.wikipedia.org/wiki/%EB%AC%BC%EB%A6%AC_%EC%A3%BC%EC%86%8C"},
        {"Physical address": "https://en.wikipedia.org/wiki/Physical_address"}
      ]
    },
    {
      "question": "___는 가상 주소를 물리 주소로 변환하는 하드웨어 장치이다.",
      "choices": [
        "Virtual-physical mapper",
        "Memory management unit",
        "Memory mapping unit",
        "Memory processing unit"
      ],
      "answer": 2,
      "explanation": "MMU (Memory Management Unit) 은 가상 주소를 물리 주소로 변환하는 것 외에도 메모리 보호나 캐시 제어 등 다양한 역할을 가지고 있습니다.",
      "references": [
        {"[한] MMU": "https://ko.wikipedia.org/wiki/%EB%A9%94%EB%AA%A8%EB%A6%AC_%EA%B4%80%EB%A6%AC_%EC%9E%A5%EC%B9%98"},
        {"MMU": "https://en.wikipedia.org/wiki/Memory_management_unit"},
        {"[한] Virtual address": "https://ko.wikipedia.org/wiki/%EA%B0%80%EC%83%81_%EC%A3%BC%EC%86%8C_%EA%B3%B5%EA%B0%84"},
        {"Virtual address": "https://en.wikipedia.org/wiki/Virtual_address_space"},
        {"[한] Physical address": "https://ko.wikipedia.org/wiki/%EB%AC%BC%EB%A6%AC_%EC%A3%BC%EC%86%8C"},
        {"Physical address": "https://en.wikipedia.org/wiki/Physical_address"}
      ]
    },
    {
      "question": "보조기억장치 (Secondary storage) 는 주기억장치 (primary storage 또는 main memory) 보다 ___.",
      "choices": [
        "용량이 크고 느리다",
        "용량이 작고 느리다",
        "용량이 크고 빠르다",
        "용량이 작고 느리다"
      ],
      "answer": 1,
      "explanation": "일반적으로 메모리 계층에서 저장소는 CPU와 가까울수록 접근 속도 (access latency) 가 짧은 대신에 bit 당 저장 비용이 비쌉니다. 따라서 멀수록 같은 가격에도 많은 용량을 저장할 수 있으므로 보조기억장치는 일반적으로 주기억장치보다 용량이 큽니다.",
      "references": [
        {"[한] Main memory": "https://ko.wikipedia.org/wiki/%EC%A3%BC%EA%B8%B0%EC%96%B5%EC%9E%A5%EC%B9%98"},
        {"Main memory": "https://en.wikipedia.org/wiki/Computer_data_storage#Primary_storage"},
        {"[한] Secondary storage": "https://ko.wikipedia.org/wiki/%EA%B8%B0%EC%96%B5_%EC%9E%A5%EC%B9%98#%EB%B3%B4%EC%A1%B0_%EA%B8%B0%EC%96%B5_%EC%9E%A5%EC%B9%98"},
        {"Secondary storage": "https://en.wikipedia.org/wiki/Computer_data_storage#Secondary_storage"},
        {"[한] Memory hierarchy": "https://ko.wikipedia.org/wiki/%EB%A9%94%EB%AA%A8%EB%A6%AC_%EA%B3%84%EC%B8%B5_%EA%B5%AC%EC%A1%B0"},
        {"Memory hierarchy": "https://en.wikipedia.org/wiki/Memory_hierarchy"}
      ]
    },
    {
      "question": "메모리 계층 구조는 다음 중 어떤 이점을 취하기 위한 하드웨어 최적화인가?",
      "choices": [
        "시간 지역성 (Temporal locality)",
        "공간 지역성 (Spatial locality)",
        "시간 지역성 및 공간 지역성 모두",
        "위에 언급된 모두 해당 안됨"
      ],
      "answer": 3,
      "explanation": "메모리 계층 구조를 통해 시간 지역성 및 공간 지역성의 이점을 최대화 하기 위해 다양한 방식으로 하드웨어가 설계되고 있습니다.",
      "references": [
        {"[한] Memory hierarchy": "https://ko.wikipedia.org/wiki/%EB%A9%94%EB%AA%A8%EB%A6%AC_%EA%B3%84%EC%B8%B5_%EA%B5%AC%EC%A1%B0"},
        {"Memory hierarchy": "https://en.wikipedia.org/wiki/Memory_hierarchy"},
        {"[한] Locality": "https://ko.wikipedia.org/wiki/%EC%BA%90%EC%8B%9C#%EC%A7%80%EC%97%AD%EC%84%B1"},
        {"Locality": "https://en.wikipedia.org/wiki/Locality_of_reference#Spatial_and_temporal_locality_usage"}
      ]
    },
    {
      "question": "___는 저장소 간의 속도 차이때문에 바로 전달되지 못하고 대기해야하는 데이터를 임시로 저장하기 위해 쓰인다.",
      "choices": [
        "Disk",
        "Cache",
        "Buffer",
        "RAM"
      ],
      "answer": 3,
      "explanation": "임시로 저장된다는 점에서 캐시와 버퍼는 비슷하게 보일 수 있습니다. 하지만 버퍼는 단순히 전달되기 전의 일시적인 상태에 불과한 데 반해, 캐시는 반복해서 쓰일 수 있다는 점 등 목적이 다양합니다.",
      "references": [
        {"[한] Cache": "https://ko.wikipedia.org/wiki/%EC%BA%90%EC%8B%9C"},
        {"[한] Buffer": "https://ko.wikipedia.org/wiki/%EB%B2%84%ED%8D%BC_(%EC%BB%B4%ED%93%A8%ED%84%B0_%EA%B3%BC%ED%95%99)"},
        {"Buffer vs Cache": "https://en.wikipedia.org/wiki/Cache_(computing)#Buffer_vs._cache"}
      ]
    },
    {
      "question": "가상 메모리를 지원하는 운영체제 하에서 CPU가 접근하는 주소체계는 ___이다.",
      "choices": [
        "실주소 (Real address)",
        "물리 주소 (Physical address)",
        "논리 주소 (Logical address)",
        "이진 주소 (Binary address)"
      ],
      "answer": 3,
      "explanation": "가상 메모리를 지원하는 운영체제에서 CPU는 논리 주소에 접근합니다. 이 때 논리 주소에 매핑된 물리 주소에 해당하는 데이터가 메인 메모리에 존재하지 않는다면 page fault가 발생하여 메인 메모리에 읽어온 후 다시 접근합니다.",
      "references": [
        {"[한] Memory address": "https://ko.wikipedia.org/wiki/%EB%A9%94%EB%AA%A8%EB%A6%AC_%EC%A3%BC%EC%86%8C"},
        {"Memory address": "https://en.wikipedia.org/wiki/Memory_address"},
        {"Page fault": "https://en.wikipedia.org/wiki/Page_fault"}
      ]
    },
    {
      "question": "가상 주소 (virtual address) 가 가리키는 2차 기억 장치에 존재하는 값을 메인 메모리에 읽어오기 위한 메모리 관리 기법을 ___라 한다.",
      "choices": [
        "Fragmentation",
        "Paging",
        "Mapping",
        "Caching"
      ],
      "answer": 2,
      "explanation": "아직 메인 메모리에 값이 존재하지 않을 때 page fault를 발생시켜 2차 기억 장치에서 메인 메모리로 데이터를 옮겨오는 작업을 페이징 (paging) 이라 합니다.",
      "references": [
        {"[한] Paging": "https://ko.wikipedia.org/wiki/%ED%8E%98%EC%9D%B4%EC%A7%95"},
        {"Paging": "https://en.wikipedia.org/wiki/Paging"}
      ]
    },
    {
      "question": "페이지 테이블의 위치를 저장하고 있는 레지스터는?",
      "choices": [
        "Stack pointer register",
        "Program counter register",
        "Status register",
        "Page table base register"
      ],
      "answer": 4,
      "explanation": "PTBR (Page Table Base Register) 은 페이지 테이블의 시작 위치를 저장하고 있는 레지스터입니다. 페이징 시에 PTBR을 참조하여 페이지 테이블에 접근하게 됩니다. 페이지 테이블의 크기를 저장하고 있는 PTLR (Page Table Length Register) 도 있습니다.",
      "references": [
        {"[한] Paging": "https://ko.wikipedia.org/wiki/%ED%8E%98%EC%9D%B4%EC%A7%95"},
        {"Paging": "https://en.wikipedia.org/wiki/Paging"}
      ]
    },
    {
      "question": "PTBR이 저장되어 있는 위치는?",
      "choices": [
        "스택 (Stack)",
        "보조기억장치 (Secondary storage)",
        "MMU",
        "PCB"
      ],
      "answer": 4,
      "explanation": "페이지 테이블은 프로세스마다 존재하므로 PTBR 값 역시 프로세스마다 다릅니다. 따라서 문맥 교환 (context switch) 이 발생할 때마다 저장 및 복구가 되어야 하므로 PCB로 관리되어 집니다.\n더불어 PCB들은 커널 영역에서 관리되므로 스왑 (swap) 대상이 아니라 보조기억장치에는 존재할 수 없습니다.",
      "references": [
        {"[한] Paging": "https://ko.wikipedia.org/wiki/%ED%8E%98%EC%9D%B4%EC%A7%95"},
        {"Paging": "https://en.wikipedia.org/wiki/Paging"},
        {"[한] PCB": "https://ko.wikipedia.org/wiki/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4_%EC%A0%9C%EC%96%B4_%EB%B8%94%EB%A1%9D"},
        {"PCB": "https://en.wikipedia.org/wiki/Process_control_block"}
      ]
    },
    {
      "question": "운영체제는 각 ___마다 페이지 테이블을 가지고 있다.",
      "choices": [
        "프로세스 (Process)",
        "프로그램 (Program)",
        "스레드 (Thread)",
        "주소 (Address)"
      ],
      "answer": 1,
      "explanation": "가상 주소에 연결되는 물리 주소는 실행 중인 프로그램마다 달라야 하기에, 프로그램이 아니라 프로세스마다 페이지 테이블을 가집니다. 한 프로세스는 여러 스레드 (thread) 를 가질 수 있는데, 이때 스레드들은 페이지 테이블을 공유하므로 스레드는 정답이 될 수 없습니다.",
      "references": [
        {"[한] Page table": "https://ko.wikipedia.org/wiki/%ED%8E%98%EC%9D%B4%EC%A7%80_%ED%85%8C%EC%9D%B4%EB%B8%94"},
        {"Page table": "https://en.wikipedia.org/wiki/Page_table"},
        {"[한] Paging": "https://ko.wikipedia.org/wiki/%ED%8E%98%EC%9D%B4%EC%A7%95"},
        {"Paging": "https://en.wikipedia.org/wiki/Paging"}
      ]
    },
    {
      "question": "다음 중 PTE가 포함하지 않는 것은?",
      "choices": [
        "Dirty bit",
        "Priority bit",
        "Present bit",
        "Physical address"
      ],
      "answer": 2,
      "explanation": "PTE는 Page Table Entry로 페이지 테이블의 한 행 (row) 또는 레코드입니다. 한 virtual address에 연관된 정보들이 저장되어 있습니다. 정보에는 물리 주소뿐만 아니라 아래와 같은 플래그 등이 포함됩니다.\n- Present bit : 페이지에 할당된 프레임이 있는지\n- Dirty bit : 페이지가 변경된 적이 있는지\n- Access bit : 페이지에 접근된 적이 있는지\n- Read/Write : 읽기/쓰기 권한",
      "references": [
        {"[한] Page table": "https://ko.wikipedia.org/wiki/%ED%8E%98%EC%9D%B4%EC%A7%80_%ED%85%8C%EC%9D%B4%EB%B8%94"},
        {"Page table": "https://en.wikipedia.org/wiki/Page_table"},
        {"[한] Paging": "https://ko.wikipedia.org/wiki/%ED%8E%98%EC%9D%B4%EC%A7%95"},
        {"Paging": "https://en.wikipedia.org/wiki/Paging"}
      ]
    },
    {
      "question": "프로세스마다 연속된 메모리 공간을 할당하는 기법을 ___라 한다.",
      "choices": [
        "Partitioned memory allocation",
        "Contiguous memory allocation",
        "Paged memory allocation",
        "Segmented memory allocation"
      ],
      "answer": 2,
      "explanation": "-",
      "references": [
        {"Memory management": "https://en.wikipedia.org/wiki/Memory_management_(operating_systems)"}
      ]
    },
    {
      "question": "실제 필요한 크기와 상관없이 메모리를 일정한 크기로 나누어 할당해주는 기법은?",
      "choices": [
        "Contiguous memory allocation",
        "Dynamic memory partitioning",
        "Fixed memory partitioning",
        "위에 언급된 모두 해당 안됨"
      ],
      "answer": 3,
      "explanation": "Fixed partitioning은 항상 운영체제에서 사전에 정의한 크기로 메모리를 할당합니다.\nContiguous allocation과 dynamic partitioning은 요청량에 따라 메모리 내의 할당 크기가 바뀔 수 있습니다. 차이점은 Contiguous는 연속된 공간인 것에 반해 dynamic은 연속되지않을 수도 있습니다.",
      "references": [
        {"Memory management": "https://en.wikipedia.org/wiki/Memory_management_(operating_systems)"}
      ]
    },
    {
      "question": "Fixed memory partitioning의 단위가 클 경우 심해질 수 있는 단편화는?",
      "choices": [
        "데이터 단편화 (Data fragmentation)",
        "외부 단편화 (External fragmentation)",
        "내부 단편화 (Internal fragmentation)",
        "위에 언급된 모두 해당 안됨"
      ],
      "answer": 3,
      "explanation": "단위가 크다면 실제로 사용되는 크기를 많이 초과하여 메모리를 할당하는 경우가 생깁니다. 예를 들어, 파티션의 단위가 128Kb라면 1Kb만 필요했을 때 127Kb가 사용되지 못한 채 낭비됩니다. 이렇게 할당받은 공간 내에서 발생하는 낭비를 내부 단편화라 합니다.",
      "references": [
        {"Memory management": "https://en.wikipedia.org/wiki/Memory_management_(operating_systems)"},
        {"[한] Fragmentation": "https://ko.wikipedia.org/wiki/%EB%8B%A8%ED%8E%B8%ED%99%94"},
        {"Fragmentation": "https://en.wikipedia.org/wiki/Fragmentation_(computing)"}
      ]
    },
    {
      "question": "외부 단편화가 심화되는 상황이 아닌 것은?",
      "choices": [
        "파일을 자주 생성하고 삭제할 때",
        "메모리 할당 요청이 오면 전체 메모리를 탐색하지않고 할당 가능한 영역을 찾으면 바로 할당할 때",
        "다양하게 큰 크기의 메모리를 할당할 때",
        "메모리 블럭의 최소 할당 크기 단위를 줄일 때"
      ],
      "answer": 4,
      "explanation": "(4)를 제외하면 모두 할당되지않은 공간이 연속되어 있을 확률을 감소시키는 동작들입니다. 외부 단편화란 할당되지않은 공간이 쪼개져 있어 충분한 여유 공간이 있음에도 불구하고 할당을 못해주는 현상을 말합니다. 따라서 할당되지않은 공간이 분산되어 있도록 만드는 것은 외부 단편화를 심화시킨다고 볼 수 있습니다.\n메모리 블럭의 할당 단위를 작게 하는 것은 할당된 공간 사이의 여유 공간이 작더라도 사용할 수 있는 확률을 높여 외부 단편화를 완화시킬 수 있는 설정이고 심화시키는 것은 아닙니다.",
      "references": [
        {"Memory management": "https://en.wikipedia.org/wiki/Memory_management_(operating_systems)"},
        {"[한] Fragmentation": "https://ko.wikipedia.org/wiki/%EB%8B%A8%ED%8E%B8%ED%99%94"},
        {"Fragmentation": "https://en.wikipedia.org/wiki/Fragmentation_(computing)"}
      ]
    },
    {
      "question": "메모리 할당 알고리즘 중 best fit은 first fit ___.",
      "choices": [
        "보다 빠르다",
        "보다 느리다",
        "보다 무조건 좋다",
        "과 시간복잡도가 같다"
      ],
      "answer": 2,
      "explanation": "Best fit은 파편화의 영향이 제일 작아지도록 할당 요청된 크기보다 같거나 큰 파편 (fragment) 중 제일 작은 것을 고르는 방식입니다. 모든 파편을 비교하기 때문에 first fit보다 느립니다.\n시간복잡도 이외에도 상황에 따라 best fit이 first fit보다 안좋을 수도 있습니다. 예를 들어 best fit은 최대한 맞는 크기의 파편을 고르다보니 할당되기 힘들 정도로 작은 크기의 파편을 많이 발생시킬 수 있습니다.",
      "references": [
        {"Memory allocation": "https://web.stanford.edu/class/archive/cs/cs140/cs140.1088/lectures/sum0708/lecture14.pdf"}
      ]
    },
    {
      "question": "메모리 할당 알고리즘 중 next fit에 대한 설명으로 틀린 것은?",
      "choices": [
        "First fit보다 외부 단편화가 덜 발생한다.",
        "Contiguous allocation에 속한다.",
        "First fit으로부터 확장된 방식이다.",
        "마지막으로 할당했던 위치를 기억해두었다가 다음 할당 시 참조한다."
      ],
      "answer": 1,
      "explanation": "메모리가 반환될 때 빈 공간의 목록인 free list의 head에 추가된다면, first fit에서는 free list의 앞 부분만 계속하여 사용할 수 있다는 이슈가 있습니다. 이를 해결하기 위해 마지막으로 할당했던 위치를 기억해두었다가 다음 할당에 참조하여, 모든 주소 공간을 순차적으로 탐색하듯이 할당해 주는 방식이 next fit입니다.\n얼핏 보기에는 first fit보다 좋을 것 같이 보이지만 일반적으로 더 안좋다는 연구들이 있습니다. 할당과 해제가 반복되면서 외부 단편화가 많아지는데, first fit은 앞 부분에서만 발생하여 뒷 부분은 큰 크기의 연속된 빈 공간이 남아있을 수 있습니다. 반면, next fit은 모든 주소 공간에 걸쳐 단편화가 발생하여 큰 크기의 메모리 요청이 왔을 때 first fit보다 대응 못할 가능성이 있습니다.",
      "references": [
        {"Memory allocation": "https://web.stanford.edu/class/archive/cs/cs140/cs140.1088/lectures/sum0708/lecture14.pdf"}
      ]
    },
    {
      "question": "외부 단편화가 발생하지 않는 상황은?",
      "choices": [
        "First fit이 사용될 때",
        "Best fit이 사용될 때",
        "Worst fit이 사용될 때",
        "위에 언급된 모두 해당 안됨"
      ],
      "answer": 4,
      "explanation": "어떤 알고리즘이 사용되든 메모리를 동적으로 할당하는 환경에서는 외부 단편화가 발생할 수 밖에 없습니다.",
      "references": [
        {"Memory allocation": "https://web.stanford.edu/class/archive/cs/cs140/cs140.1088/lectures/sum0708/lecture14.pdf"}
      ]
    },
    {
      "question": "버디 메모리 할당에 대한 설명으로 맞는 것은?",
      "choices": [
        "외부 단편화가 심화된다.",
        "내부 단편화가 심화된다.",
        "내부 단편화가 완화된다.",
        "2의 배수 단위로 할당한다."
      ],
      "answer": 2,
      "explanation": "버디 메모리 할당 (Buddy memory allocation) 은 주소 공간을 2의 거듭제곱 값으로 나누어 할당하는 방식입니다. 따라서 최소 할당 단위가 있어 할당되는 경우의 수가 제한적인 대신에 외부 단편화가 완화됩니다. 반면 최소 단위가 있기 때문에 내부 단편화는 심해집니다. 예를 들어 최소 단위가 64Kb면 1Kb만 필요해도 64Kb가 할당되어 63Kb의 메모리 낭비, 즉 내부 단편화가 발생합니다.",
      "references": [
        {"[한] Buddy memory allocation": "https://ko.wikipedia.org/wiki/%EB%B2%84%EB%94%94_%EB%A9%94%EB%AA%A8%EB%A6%AC_%ED%95%A0%EB%8B%B9"},
        {"Buddy memory allocation": "https://en.wikipedia.org/wiki/Buddy_memory_allocation"},
        {"Memory allocation": "https://web.stanford.edu/class/archive/cs/cs140/cs140.1088/lectures/sum0708/lecture14.pdf"}
      ]
    },
    {
      "question": "PTE가 가지는 순서쌍에 대한 의미로 맞는 것은?",
      "choices": [
        "(페이지 번호, 프레임 번호)",
        "(프레임 번호, 페이지 번호)",
        "(페이지 번호, 페이지 변위)",
        "(프레임 번호, 페이지 변위)"
      ],
      "answer": 1,
      "explanation": "PTE (Page Table Entry) 의 순서쌍은 가상 주소로부터 물리 주소로 변환될 수 있는 정보를 포함합니다. 구체적으로 페이지 번호 (page number) 에 해당하는 프레임 번호 (frame number) 를 제공하여, 페이지 변위 (page offset) 를 더해 물리 주소로 변환할 수 있습니다.\n가상 주소는 프로세스의 페이지를 나타내므로 순서쌍의 key가 물리 주소와 연관된 프레임 번호가 될 수 없습니다.",
      "references": [
        {"[한] Page table": "https://ko.wikipedia.org/wiki/%ED%8E%98%EC%9D%B4%EC%A7%80_%ED%85%8C%EC%9D%B4%EB%B8%94"},
        {"Page table": "https://en.wikipedia.org/wiki/Page_table"},
        {"[한] Paging": "https://ko.wikipedia.org/wiki/%ED%8E%98%EC%9D%B4%EC%A7%95"},
        {"Paging": "https://en.wikipedia.org/wiki/Paging"}
      ]
    },
    {
      "question": "프로세스가 실제로 사용하는 물리 메모리의 크기를 알기 위해 필요한 것은?",
      "choices": [
        "PC (Program Counter)",
        "PTBR (Page Table Base Register)",
        "PTLR (Page Table Length Register)",
        "위에 언급된 모두 해당 안됨"
      ],
      "answer": 4,
      "explanation": "페이지 테이블 자체의 크기는 PTLR로 구할 수 있습니다. 하지만 페이지 테이블의 모든 엔트리가 유효하지 않기 때문에 테이블의 크기 만으로는 사용 중인 크기를 알 수 없습니다. 실제로 가상 주소를 통한 메모리 접근이 있을 때 page fault가 발생하여 채워지게 됩니다.\nPC는 현재 실행 중인 코드의 주소로 페이지 테이블과는 상관 없습니다.\n따라서 실제 사용 중인 물리 메모리의 크기는 페이지 테이블의 모든 엔트리를 탐색하여 유효한 페이지 수를 구하고 페이지의 크기를 곱하여 구할 수 있습니다.",
      "references": [
        {"[한] Page table": "https://ko.wikipedia.org/wiki/%ED%8E%98%EC%9D%B4%EC%A7%80_%ED%85%8C%EC%9D%B4%EB%B8%94"},
        {"Page table": "https://en.wikipedia.org/wiki/Page_table"},
        {"[한] Paging": "https://ko.wikipedia.org/wiki/%ED%8E%98%EC%9D%B4%EC%A7%95"},
        {"Paging": "https://en.wikipedia.org/wiki/Paging"}
      ]
    },
    {
      "question": "TLB 사용 시 TLB에 접근하려고 하는 페이지의 page number가 없는 상황을 ___라 한다.",
      "choices": [
        "TLB hit",
        "TLB miss",
        "Page miss",
        "Page fault"
      ],
      "answer": 2,
      "explanation": "Translation Looakside Buffer (TLB) 는 페이지 테이블의 캐시 역할으로 기존에 접근이 있었어서 참조할 것이 있는 경우 hit, 없었을 경우 miss라고 합니다. hit될 경우 페이지 테이블을 확인할 필요가 없어 가상 주소와 물리 주소 간의 변환을 빠르게 할 수 있습니다.",
      "references": [
        {"[한] TLB": "https://ko.wikipedia.org/wiki/%EB%B3%80%ED%99%98_%EC%83%89%EC%9D%B8_%EB%B2%84%ED%8D%BC"},
        {"TLB": "https://en.wikipedia.org/wiki/Translation_lookaside_buffer"}
      ]
    },
    {
      "question": "TLB에서 page number에 해당하는 frame number를 찾을 수 있었던 확률을 나타내는 용어는?",
      "choices": [
        "TLB hit count",
        "TLB miss count",
        "TLB hit ratio",
        "TLB miss ratio"
      ],
      "answer": 3,
      "explanation": "Hit ratio는 TLB에서 뿐만 아니라 캐시의 효율을 평가하기 위해 널리 사용되는 개념입니다. hit count를 hit + miss count로 나누어 구할 수 있습니다.",
      "references": [
        {"[한] TLB": "https://ko.wikipedia.org/wiki/%EB%B3%80%ED%99%98_%EC%83%89%EC%9D%B8_%EB%B2%84%ED%8D%BC"},
        {"TLB": "https://en.wikipedia.org/wiki/Translation_lookaside_buffer"}
      ]
    },
    {
      "question": "TLB hit ratio가 0.8이고 캐시 접근 시간이 1 ns, 메인 메모리 접근 시간이 100 ns일 때 평균 접근 시간 (average access time) 은?",
      "choices": [
        "21 ns",
        "20.8 ns",
        "81 ns",
        "80.2 ns"
      ],
      "answer": 1,
      "explanation": "평균 접근 시간 (혹은 effective access time) 은 캐시 접근 시간에 miss ratio에 메인 메모리 접근 시간을 곱해 구할 수 있습니다. hit이든 miss이든 TLB 확인을 위해 캐시 접근은 무조건 하므로 캐시 접근 시간은 hit ratio와 상관없이 더해집니다. miss ratio는 1에서 hit ratio를 빼면 됩니다. 따라서 1 + (1 - 0.8) * 100 = 21 ns 이 됩니다.",
      "references": [
        {"[한] TLB": "https://ko.wikipedia.org/wiki/%EB%B3%80%ED%99%98_%EC%83%89%EC%9D%B8_%EB%B2%84%ED%8D%BC"},
        {"TLB": "https://en.wikipedia.org/wiki/Translation_lookaside_buffer"}
      ]
    },
    {
      "question": "다음 중 페이지 테이블의 종류가 아닌 것은?",
      "choices": [
        "Multi-level page table",
        "Fixed page table",
        "Hashed page table",
        "Inverted page table"
      ],
      "answer": 2,
      "explanation": "\n- Multi-level page table: 물리 주소로 변환하기 위해 참조해야 하는 페이지 테이블을 하나가 아니라 여러 개로 나누어 관리하는 기법. 계층적 페이지 테이블 (Hierarchical page table) 이라고도 합니다.\n- Hashed page table: 페이지 테이블의 key를 page number 대신 가상 주소를 hash function에 넣은 결과를 사용하는 기법.\n- Inverted page table: 전형적인 페이지 테이블과는 반대로 frame number를 key로 사용하는 기법.",
      "references": [
        {"[한] Paging": "https://ko.wikipedia.org/wiki/%ED%8E%98%EC%9D%B4%EC%A7%95"},
        {"Paging": "https://en.wikipedia.org/wiki/Paging"}
      ]
    },
    {
      "question": "다양한 페이지 테이블 기법들이 있는 이유 중 하나는 ___ 위해서다.",
      "choices": [
        "주소 변환 속도를 빠르게 하기",
        "더 많은 정보를 저장하기",
        "페이지 테이블의 크기를 줄이기",
        "위에 언급된 모두 해당"
      ],
      "answer": 3,
      "explanation": "페이지 테이블은 프로세스마다 존재하므로 프로세스가 많아 질수록 요구되는 메모리 크기와 overhead가 커지게 됩니다. 각 프로세스에서 항상 모든 페이지에 접근하지는 않으므로 사용되지않는 페이지를 위해 미리 큰 공간을 할당하는 것을 피하는 방법들이 제안되었습니다.",
      "references": [
        {"[한] Paging": "https://ko.wikipedia.org/wiki/%ED%8E%98%EC%9D%B4%EC%A7%95"},
        {"Paging": "https://en.wikipedia.org/wiki/Paging"}
      ]
    },
    {
      "question": "Paged memory system에서 페이지 크기를 크게 한다면 내부 단편화 (internal fragmentation) 는 ___.",
      "choices": [
        "완화된다",
        "심해진다",
        "변화없다",
        "알 수 없다"
      ],
      "answer": 2,
      "explanation": "Fixed memory partitioning의 단위가 커지는 것과 같은 경우로, 실제로 사용되는 크기보다 큰 단위로 메모리의 전송이 발생할 확률이 높아집니다.",
      "references": [
        {"Memory management": "https://en.wikipedia.org/wiki/Memory_management_(operating_systems)"},
        {"[한] Fragmentation": "https://ko.wikipedia.org/wiki/%EB%8B%A8%ED%8E%B8%ED%99%94"},
        {"Fragmentation": "https://en.wikipedia.org/wiki/Fragmentation_(computing)"}
      ]
    }
  ]
}
