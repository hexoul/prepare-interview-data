{
  "questions": [
    {
      "question": "여러 프로세스가 같은 데이터를 동시에 접근할 때 실행 결과가 접근 순서에 의존하는 상황을 ___이라 한다.",
      "choices": [
        "Dynamic condition",
        "Race condition",
        "Essential condition",
        "Critical condition"
      ],
      "answer": 2,
      "explanation": "교착 상태 (race condition) 란 여러 프로세스가 공유 자원을 사용할 때 접근 순서에 따라 결과가 바뀔 수 있는 상태를 말합니다. 교착 상태에서는 기대 결과가 보장되지 않으므로 교착 상태가 되지 않도록 방지할 필요가 있습니다.",
      "references": [
        {"Race condition": "https://en.wikipedia.org/wiki/Race_condition#Software"}
      ]
    },
    {
      "question": "만약 한 프로세스가 임계 구역 (critical section) 을 실행 중이라면, 다른 프로세스들은 자신의 임계 구역을 실행할 수 없게 된다. 이를 무엇이라 하는가?",
      "choices": [
        "Mutual exclusion",
        "Critical exclusion",
        "Synchronous exclusion",
        "Asynchronous exclusion"
      ],
      "answer": 1,
      "explanation": "임계 구역 (Critical section) 은 동시에 한 프로세스만 진입할 수 있고 병렬도를 위해 일정시간 이상의 수행은 허용되지 않습니다.",
      "references": [
        {"[한] Critical section": "https://ko.wikipedia.org/wiki/%EC%9E%84%EA%B3%84_%EA%B5%AC%EC%97%AD"},
        {"Critical section": "https://en.wikipedia.org/wiki/Critical_section"}
      ]
    },
    {
      "question": "다음 중 동기화에 쓰이는 자원은?",
      "choices": [
        "스레드 (Thread)",
        "파이프 (Pipe)",
        "세마포어 (Semaphore)",
        "소켓 (Socket)"
      ],
      "answer": 3,
      "explanation": "-",
      "references": [
        {"[한] Pipe": "https://ko.wikipedia.org/wiki/%ED%8C%8C%EC%9D%B4%ED%94%84_(%EC%9C%A0%EB%8B%89%EC%8A%A4)"},
        {"Pipe": "https://en.wikipedia.org/wiki/Pipeline_(Unix)"},
        {"[한] Semaphore": "https://ko.wikipedia.org/wiki/%EC%84%B8%EB%A7%88%ED%8F%AC%EC%96%B4"},
        {"Semaphore": "https://en.wikipedia.org/wiki/Semaphore_(programming)"}
      ]
    },
    {
      "question": "상호 배제 (Mutual exclusion) 는 ___을 통해 구현할 수 있다.",
      "choices": [
        "뮤텍스 (Mutex)",
        "이진 세마포어 (Binary semaphore)",
        "뮤텍스와 이진 세마포어",
        "위에 언급된 모두 해당 안됨"
      ],
      "answer": 3,
      "explanation": "이진 세마포어 (Binary semaphore)는 뮤텍스 (mutex) 라고도 합니다.",
      "references": [
        {"[한] Mutex": "https://ko.wikipedia.org/wiki/%EB%9D%BD_(%EC%BB%B4%ED%93%A8%ED%84%B0_%EA%B3%BC%ED%95%99)"},
        {"Mutex": "https://en.wikipedia.org/wiki/Lock_(computer_science)"},
        {"[한] Semaphore": "https://ko.wikipedia.org/wiki/%EC%84%B8%EB%A7%88%ED%8F%AC%EC%96%B4"},
        {"Semaphore": "https://en.wikipedia.org/wiki/Semaphore_(programming)"}
      ]
    },
    {
      "question": "High priority task가 medium priority task에 의해 간접적으로 선점되어질 때 두 태스크의 상대 우선순위가 도치된다. 이런 상황을 무엇이라 하는가?",
      "choices": [
        "Priority removal",
        "Priority inversion",
        "Priority exchange",
        "Priority modification"
      ],
      "answer": 2,
      "explanation": "-",
      "references": [{"Prirority inversion": "https://en.wikipedia.org/wiki/Priority_inversion"}]
    },
    {
      "question": "프로세스 동기화는 ___에서 이루어진다.",
      "choices": [
        "hardware level",
        "software level",
        "hardware and software level",
        "모두 해당 안됨"
      ],
      "answer": 3,
      "explanation": "Critical section을 기반으로 한 프로세스 선점 (preemption) 제어는 hardware와 software에서 모두 이루어질 수 있습니다. Software level은 OS scheduling 기법들로 구현될 수 있습니다. Hardware level의 예로는 interrupt를 일시적으로 disable 시키거나 lock 제어를 위한 compare-and-swap을 hardware instruction level로 제공하는 것이 있습니다.",
      "references": [
        {"Hardware synchronization": "https://en.wikipedia.org/wiki/Synchronization_(computer_science)#Hardware_synchronization"}
      ]
    },
    { 
      "question": "Inter-process communication (IPC) 란?",
      "choices": [
        "같은 주소 공간을 사용할 때 프로세스 간에 행해지는 통신과 동기화",
        "같은 주소 공간을 사용하지않는 프로세스 간의 통신과 동기화",
        "프로세스 간에 통신없이 동기화",
        "네트워크를 통한 프로세스 간의 통신과 동기화"
      ],
      "answer": 2,
      "explanation": "IPC는 프로세스 간에 데이터를 공유하기위해 통신을 가능하게 만드는 메커니즘으로, 이는 파일, 소켓, 메세지큐 등을 통해 다양하게 구현될 수 있습니다. 따라서 네트워크를 통하는 것만이라고 한정지을 수 없습니다. 보기 1의 설명은 IPC의 설명으로는 맞지않고 통신 부분을 뺀다면 critical section을 통해 동기화하는 semaphore 등의 동기화 기법의 설명으로 볼 수 있습니다.",
      "references": [{"IPC": "https://en.wikipedia.org/wiki/Inter-process_communication"}]
    },
    {
      "question": "Message passing 시스템은 프로세스가 ___ 하는 것을 가능하게 해준다.",
      "choices": [
        "공유 데이터를 사용하지않고 다른 프로세스와 통신",
        "공유 데이터를 사용하여 다른 프로세스와 통신",
        "다른 프로세스에 데이터를 직접 공유",
        "메세지의 발신자와 수신자의 이름을 기록"
      ],
      "answer": 1,
      "explanation": "Message passing 시스템은 메세지 큐 또는 채널을 통해 메세지를 전달하는 시스템으로 수신 측에서 가져가는 작업이 있어야만 데이터가 최종적으로 전달됩니다.",
      "references": [{"Message passing": "https://en.wikipedia.org/wiki/Message_passing"}]
    },
    {
      "question": "다음 중 IPC로부터 제공받는 두 operation은?",
      "choices": [
        "write & delete message",
        "delete & receive message",
        "send & delete message",
        "receive & send message"
      ],
      "answer": 4,
      "explanation": "-",
      "references": [
        {"IPC": "https://en.wikipedia.org/wiki/Inter-process_communication"}
      ]
    },
    {
      "question": "프로세스로부터 보내지는 메세지의 크기는 ___",
      "choices": [
        "고정되어야 한다.",
        "가변이어야 한다.",
        "고정일 수도 있고 가변일 수도 있다.",
        "운영체제마다 다르다."
      ],
      "answer": 3,
      "explanation": "메세지 크기는 고정과 가변 둘 다 가능하며 각각 장단점이 있습니다. 고정일 경우 OS 설계자 입장에서는 구현이 간단해지지만 애플리케이션 개발자 입장에서는 구현이 복잡해질 수 있습니다. 반대로 가변일 경우 OS 설계자 입장에서는 복잡해지지만 애플리케이션 개발자는 보다 쉽게 개발할 수 있는 여지가 생깁니다.\n\n결과적으로 고정과 가변을 모두 제공하기 위해서 표준 메세지는 고정된 크기의 header와 가변 body를 가집니다. Header에 메세지 제어를 위한 정보와 함께 길이 정보도 있어 이에 기반하여 body 범위를 인지하고 얻어옵니다.",
      "references": [
        {"Message passing": "https://www.geeksforgeeks.org/inter-process-communication-ipc"}
      ]
    },
    {
      "question": "메세지를 보내고 받기 위한 두 프로세스 간의 링크를 ___라 한다.",
      "choices": [
        "Communication link",
        "Message-passing link",
        "Synchronization link",
        "Process link"
      ],
      "answer": 1,
      "explanation": "-",
      "references": [
        {"Communication link": "https://www.geeksforgeeks.org/inter-process-communication-ipc"}
      ]
    },
    {
      "question": "다음 중 direct communication에 대해 맞는 설명은?",
      "choices": [
        "하나의 communication link가 N 개의 프로세스와 연결될 수 있다.",
        "하나의 communication link는 정확히 두 프로세스와만 연결된다.",
        "N 개의 프로세스가 있을 때 정확히 N/2 개의 communication link가 존재한다.",
        "연결된 두 프로세스의 쌍(pair)마다 정확히 두 개의 링크를 가진다."
      ],
      "answer": 2,
      "explanation": "한 프로세스가 여러 프로세스와 연결될 수 있고 각 연결에서 한 link가 쓰이므로, N 개의 프로세스가 있다면 조합의 수인 nC2 = N! / 2! * (N - 2)! 개 만큼 link가 존재할 수 있습니다.",
      "references": [
        {"Communication link": "https://www.geeksforgeeks.org/inter-process-communication-ipc"},
        {"Combination": "https://en.wikipedia.org/wiki/Combination"}
      ]
    },
    {
      "question": "다음 중 프로세스 P와 Q의 indirect communication에 대해 맞는 설명은?",
      "choices": [
        "프로세스 P와 Q 사이에서 메세지를 받아 전달해주는 프로세스 R이 존재한다.",
        "두 프로세스 간의 통신을 돕기위한 별도 머신이 존재한다.",
        "두 프로세스 간의 통신을 돕기위한 mailbox가 존재한다.",
        "direct communication보다 느리다."
      ],
      "answer": 3,
      "explanation": "Indirect communication에서 송신자는 메세지를 mailbox에 저장하고 수신자는 메세지를 mailbox로부터 꺼내가게 됩니다. 속도에 관해서는 communication 자체의 구현뿐만 아니라 송수신 측의 구현에도 의존하므로 direct냐 indirect냐만 가지고 단적으로 속도 비교를 할 수는 없습니다.",
      "references": [
        {"Communication link": "https://www.geeksforgeeks.org/inter-process-communication-ipc"}
      ]
    },
    {
      "question": "Non-blocking 프로세스는 ___",
      "choices": [
        "메세지가 수신될 때까지 계속하여 메세지를 보낸다.",
        "메세지를 받을 때까지 계속하여 메세지를 보낸다.",
        "메세지를 보내고 메세지를 받을 때까지 대기한다.",
        "메세지를 보내고 작업을 재개한다."
      ],
      "answer": 4,
      "explanation": "비동기 프로세스는 다른 쓰레드의 작업을 실패시키거나 중지시키면 안되기때문에, 메세지를 보내는 경우 쓰기만 하고 결과는 polling 등을 통해 추후에 확인합니다.",
      "references": [
        {"Non-blocking algorithm": "https://en.wikipedia.org/wiki/Non-blocking_algorithm"},
        {"Asynchronous I/O": "https://en.wikipedia.org/wiki/Asynchronous_I/O"}
      ]
    },
    {
      "question": "Zero capacity queue에 대해서 올바른 설명은?",
      "choices": [
        "Queue가 적어도 하나의 메세지를 저장할 수 있다.",
        "송신자는 수신자가 메세지를 받아갈 때까지 블록된다.",
        "송신자는 계속해서 메세지를 보낼 수 있지만 메세지가 queue에 머무르지 않는다.",
        "송신자는 상황에 따라 블록될 수도 안될 수도 있다."
      ],
      "answer": 2,
      "explanation": "Zero capacity queue란 queue의 크기가 0인 것을 의미하므로, 메세지 전달을 보장하기 위해서 송신자는 수신자가 메세지를 받아갈 때까지 블록되어야 합니다.",
      "references": [
        {"Queue": "https://en.wikipedia.org/wiki/Queue_(abstract_data_type)"}
      ]
    },
    {
      "question": "Zero capacity queue는 ___라고도 불린다.",
      "choices": [
        "No-buffering message system",
        "Buffering message system",
        "Process link",
        "Unbounded link"
      ],
      "answer": 1,
      "explanation": "Zero capacity queue란 queue의 크기가 0인 것을 의미합니다. 따라서 queue에 공간이 없기 때문에 메세지가 쌓여 대기할 수 없고 버퍼링이 존재하지않게 됩니다.",
      "references": [
        {"Queue": "https://en.wikipedia.org/wiki/Queue_(abstract_data_type)"}
      ]
    },
    {
      "question": "Bounded 또는 unbounded capacity queue는 ___라고 볼 수 있다.",
      "choices": [
        "프로그램되어진 버퍼링",
        "자동 버퍼링",
        "사용자 정의 버퍼링",
        "No buffering"
      ],
      "answer": 2,
      "explanation": "Bounded 또는 unbounded capacity queue는 queue의 길이가 제한 (bounded) 되었거나 무한대 (unbounded) 인 queue를 의미합니다. 따라서 프로세스를 블록시키도록 프로그래밍한 것이 아니라 queue의 특성과 사용 패턴에 따라 자동으로 버퍼링되는 것이므로 automatic 또는 explicit buffering이라고 합니다.",
      "references": [
        {"Queue": "https://en.wikipedia.org/wiki/Queue_(abstract_data_type)"}
      ]
    },
    {
      "question": "Non-blocking 알고리즘의 wait-free와 lock-free에 대한 설명으로 틀린 것은?",
      "choices": [
        "Wait-free 알고리즘 하에서는 기아 (starvation) 가 없다.",
        "Lock-free 알고리즘은 lock이 없어 공유 자원을 위한 경쟁이 필요없다.",
        "모든 wait-free 알고리즘은 lock-free이다.",
        "wait-free 알고리즘이 lock-free보다 구현이 어렵다."
      ],
      "answer": 2,
      "explanation": "Wait-free는 non-blocking에서 가장 강력한 자유도를 보장하는 수준으로 반응성이 보장되어야하는 실시간 시스템에서 중요한 특성입니다. 강력한 대신에 구현이 어렵고 제약이 많습니다. Lock-free는 lock이 없다는 것이 아니라 대기 시간이 bound 되어있다는 의미로, wait-free와는 달리 자원 경쟁이 있어 기아가 발생할 수 있으나 유한한 시간 내에 공유 자원을 획득할 수 있습니다. Wait-free가 lock-free보다 조건이 엄격하므로 모든 wait-free는 lock-free에도 해당합니다.",
      "references": [
        {"Wait-free": "https://en.wikipedia.org/wiki/Non-blocking_algorithm#Wait-freedom"},
        {"Lock-free": "https://en.wikipedia.org/wiki/Non-blocking_algorithm#Lock-freedom"}
      ]
    },
    {
      "question": "Non-blocking 알고리즘의 freedom level에 따른 설명으로 틀린 것은?",
      "choices": [
        "모든 wait-free 알고리즘은 obstruction-free이다.",
        "모든 lock-free 알고리즘은 obstruction-free이다.",
        "모든 obstruction-free 알고리즘은 lock-free이다.",
        "obstruction-free 알고리즘이 가장 약한 수준의 자유도를 보장한다."
      ],
      "answer": 3,
      "explanation": "Wait-free에서 lock-free, obstruction-free로 갈수록 자유도를 덜 보장받습니다. 따라서 lock-free는 obstruction-free를 위한 조건도 충족시키지만, 반대로 obstruction-free는 lock-free의 조건을 충족시킬 수 없습니다.",
      "references": [
        {"Wait-free": "https://en.wikipedia.org/wiki/Non-blocking_algorithm#Wait-freedom"},
        {"Lock-free": "https://en.wikipedia.org/wiki/Non-blocking_algorithm#Lock-freedom"},
        {"Obstruction-free": "https://en.wikipedia.org/wiki/Non-blocking_algorithm#Obstruction-freedom"}
      ]
    },
    {
      "question": "Remote Procedure Call (RPC) 은 ___ 하기위해 사용된다.",
      "choices": [
        "같은 프로그램 내의 프로시저를 호출",
        "같은 시스템 내의 프로시저를 호출",
        "시스템 상관없이 프로시저를 호출",
        "IPC가 지원하지 못하는 부분을 보충"
      ],
      "answer": 3,
      "explanation": "RPC는 별도의 원격 제어를 위한 코딩없이 다른 주소 공간에 있는 프로시저를 실행시키는 기법으로, 프로시저가 로컬에 있든 원격에 있든 상관없이 동일하게 실행할 수 있는 추상화 인터페이스를 프로그래머에 제공합니다. RPC는 IPC의 한 형태이므로 4번도 틀린 설명입니다.",
      "references": [
        {"[한] RPC": "https://ko.wikipedia.org/wiki/%EC%9B%90%EA%B2%A9_%ED%94%84%EB%A1%9C%EC%8B%9C%EC%A0%80_%ED%98%B8%EC%B6%9C"},
        {"RPC": "https://en.wikipedia.org/wiki/Remote_procedure_call"}
      ]
    },
    {
      "question": "RPC는 별도의 원격 제어없이 다른 주소 공간의 프로시저를 호출하기위해 ___를 제공한다.",
      "choices": [
        "identifier",
        "stub",
        "alias",
        "process"
      ],
      "answer": 2,
      "explanation": "stub은 일반적으로 RPC를 위해 자동생성되어지는 코드입니다. 호출 시 클라이언트 사이드 stub에서는 매개변수 (parameter) 를 packing (혹은 marshalling) 하고, 서버 사이드 stub (혹은 skeleton) 에서는 unpacking (혹은 unmarshalling) 하여 매개변수를 전달받습니다. 응답 시에는 위 과정을 반대 순서로 진행합니다.",
      "references": [
        {"[한] RPC": "https://ko.wikipedia.org/wiki/%EC%9B%90%EA%B2%A9_%ED%94%84%EB%A1%9C%EC%8B%9C%EC%A0%80_%ED%98%B8%EC%B6%9C"},
        {"RPC": "https://en.wikipedia.org/wiki/Remote_procedure_call"},
        {"stub": "https://en.wikipedia.org/wiki/Stub_(distributed_computing)"}
      ]
    },
    {
      "question": "클라이언트 사이드 stub이 하는 것은?",
      "choices": [
        "서버 사이드에 메세지 전달",
        "전달할 매개변수 marshalling",
        "전달받은 응답 unmarshalling",
        "위에 언급된 모두 해당"
      ],
      "answer": 4,
      "explanation": "-",
      "references": [
        {"stub": "https://en.wikipedia.org/wiki/Stub_(distributed_computing)"},
        {"Marshalling": "https://en.wikipedia.org/wiki/Marshalling_(computer_science)"},
        {"Unmarshalling": "https://en.wikipedia.org/wiki/Marshalling_(computer_science)#Unmarshalling"}
      ]
    },
    {
      "question": "RMI란?",
      "choices": [
        "Remote Memory Installation",
        "Remote Memory Invocation",
        "Remote Method Installation",
        "Remote Method Invocation"
      ],
      "answer": 4,
      "explanation": "-",
      "references": [
        {"RMI": "https://en.wikipedia.org/wiki/Distributed_object_communication"},
        {"Java RMI": "https://en.wikipedia.org/wiki/Java_remote_method_invocation"}
      ]
    },
    {
      "question": "동기화없이 공유 데이터를 동시 접근하는 것은 ___를 야기한다.",
      "choices": [
        "Data consistency",
        "Data inconsistency",
        "Data insecurity",
        "Data breach"
      ],
      "answer": 2,
      "explanation": "데이터를 읽고 쓰는 순서와 시간이 보장되지 않는다면, 부적절한 시점의 데이터가 읽히거나 덮어써지는 등 데이터 일관성을 해치는 문제가 발생합니다.",
      "references": [
        {"Data consistency": "https://en.wikipedia.org/wiki/Data_consistency"}
      ]
    },
    {
      "question": "공유 자원에 동시접근했을 때 의도치 않은 동작이 발생할 수 있기 때문에, 동시접근을 막기위해 다른 프로세스 들로부터 보호받는 코드 구간을 무엇이라 하는가?",
      "choices": [
        "Secure section",
        "Critical section",
        "Non-critical section",
        "Synchorinzed section"
      ],
      "answer": 2,
      "explanation": "-",
      "references": [
        {"[한] Critical section": "https://ko.wikipedia.org/wiki/%EC%9E%84%EA%B3%84_%EA%B5%AC%EC%97%AD"},
        {"Critical section": "https://en.wikipedia.org/wiki/Critical_section"}
      ]
    },
    {
      "question": "다음 중 critical section 문제를 풀기 위해 만족되어야 하는 상태는?",
      "choices": [
        "Mutual exclusion",
        "Progress",
        "Bounded waiting",
        "위에 언급된 모두 해당"
      ],
      "answer": 4,
      "explanation": "-",
      "references": [
        {"Critical section": "https://en.wikipedia.org/wiki/Critical_section"},
        {"Mutual exclusion": "https://en.wikipedia.org/wiki/Mutual_exclusion"},
        {"Bounded waiting": "https://en.wikipedia.org/wiki/Peterson%27s_algorithm#Bounded_waiting"}
      ]
    },
    {
      "question": "상호 배제 (Mutual exclusion) 하에서는 만약 한 프로세스가 자신의 critical section을 실행하고 있다면 ___",
      "choices": [
        "다른 프로세스들은 critical section을 실행하고 있으면 안된다.",
        "다른 프로세스들도 critical section을 실행하고 있어야 한다.",
        "수행이 끝날 때까지 모든 시스템 자원은 블록되어야 한다.",
        "모두 해당 안됨"
      ],
      "answer": 1,
      "explanation": "-",
      "references": [
        {"Critical section": "https://en.wikipedia.org/wiki/Critical_section"},
        {"Mutual exclusion": "https://en.wikipedia.org/wiki/Mutual_exclusion"}
      ]
    },
    {
      "question": "Bounded waiting이란 어떤 프로세스가 ___ critical section에 진입할 때까지의 시간이 유한한 것을 말한다.",
      "choices": [
        "critical section을 수행 중이던 프로세스의 종료 후",
        "critical section 요청 진입 후",
        "한 번 critical section 수행을 마친 후 다시",
        "모두 해당 안됨"
      ],
      "answer": 2,
      "explanation": "-",
      "references": [
        {"Critical section": "https://en.wikipedia.org/wiki/Critical_section"},
        {"Bounded waiting": "https://en.wikipedia.org/wiki/Peterson%27s_algorithm#Bounded_waiting"}
      ]
    },
    {
      "question": "Critical section problem을 해결하기 위해서는 최소 ___ 개의 변수가 공유되어야 한다.",
      "choices": [
        "1",
        "2",
        "3",
        "4"
      ],
      "answer": 2,
      "explanation": "Critical section problem을 단순화시키기 위해 두 프로세스만 있다고 가정했을 때의 풀이들을 보면 답을 이해하는데에 도움이 됩니다. e.g. Dekker's algorithm 또는 Peterson's algorithm",
      "references": [
        {"Critical section": "https://en.wikipedia.org/wiki/Critical_section"},
        {"Dekker's algorithm": "https://en.wikipedia.org/wiki/Dekker%27s_algorithm"},
        {"Peterson's algorithm": "https://en.wikipedia.org/wiki/Peterson%27s_algorithm"}
      ]
    },
    {
      "question": "Bakery algorithm은 ___",
      "choices": [
        "각 프로세스를 큐에 삽입한 후 순서대로 자원을 할당한다.",
        "각 프로세스에 중복될 수도 있는 번호를 주고 제일 작은 번호를 가진 프로세스부터 자원을 할당한다.",
        "각 프로세스에 고유 번호를 주고 제일 높은 번호를 가진 프로세스부터 자원을 할당한다.",
        "각 프로세스에 고유 번호를 주고 제일 작은 번호를 가진 프로세스부터 자원을 할당한다."
      ],
      "answer": 2,
      "explanation": "-",
      "references": [
        {"Lamport's bakery algorithm": "https://en.wikipedia.org/wiki/Lamport's_bakery_algorithm"}
      ]
    },
    {
      "question": "Concurrent programming에서 인터럽트에 영향을 받지않는 operation을 ___ operation이라 한다.",
      "choices": [
        "Single",
        "Static",
        "Atomic",
        "Non-atomic"
      ],
      "answer": 3,
      "explanation": "Atomicity은 원자성이라하여 다른 operation에 방해를 받지 않습니다. Linearizability라고도 합니다.",
      "references": [
        {"Concurrent programming": "https://en.wikipedia.org/wiki/Concurrent_computing"},
        {"Linearizability": "https://en.wikipedia.org/wiki/Linearizability"}
      ]
    },
    {
      "question": "TestAndSet 명령어는 ___ 실행된다.",
      "choices": [
        "특정 프로세스의 실행 후에",
        "주기적으로",
        "원자성을 가지고",
        "비동기적으로"
      ],
      "answer": 3,
      "explanation": "Test-and-set 명령어는 상호 배제 등 동시성을 제어하기 위해 쓰이는 명령어로 인터럽지되지 않습니다. HW 레벨에서 구현될 수도 있고 SW 레벨에서 구현될 수도 있습니다.",
      "references": [
        {"[한] TestAndSet": "https://ko.wikipedia.org/wiki/%EA%B2%80%EC%82%AC%EC%99%80_%EC%A7%80%EC%A0%95"},
        {"TestAndSet": "https://en.wikipedia.org/wiki/Test-and-set"}
      ]
    },
    {
      "question": "Semaphore는 critical section problem을 풀기 위한 ___이다.",
      "choices": [
        "하드웨어",
        "소프트웨어",
        "변수",
        "모두 해당 안됨"
      ],
      "answer": 3,
      "explanation": "세마포어는 멀티프로세싱 환경에서 동시성 제어를 위해 사용되는 변수로 세마포어 자체는 기법이 아니라 숫자만을 의미합니다. 나아가 세마포어가 가지는 수에 따라 counting semaphore 또는 binary semaphore 라고 불립니다.",
      "references": [
        {"[한] Semaphore": "https://ko.wikipedia.org/wiki/%EC%84%B8%EB%A7%88%ED%8F%AC%EC%96%B4"},
        {"Semaphore": "https://en.wikipedia.org/wiki/Semaphore_(programming)"}
      ]
    },
    {
      "question": "Spinlock에 대한 맞는 설명은?",
      "choices": [
        "Critical section 진입이 불가할때 CPU를 낭비한다.",
        "Context switching 시간을 절약하기위해 사용된다.",
        "싱글프로세서보다 멀티프로세서에서 보다 효율적이다.",
        "위에 언급된 모두 해당"
      ],
      "answer": 4,
      "explanation": "Spinlock은 진입이 가능할 때까지 진입을 계속하여 시도하는 busy waiting lock입니다. 따라서 대기시간이 짧다면 context switching없이 critical section에 진입할 수 있어 효율적이지만, 프로세서가 적을 때 사용되면 다른 프로세스를 방해할 가능성이 커진다는 단점이 있습니다.",
      "references": [
        {"[한] Spinlock": "https://ko.wikipedia.org/wiki/%EC%8A%A4%ED%95%80%EB%9D%BD"},
        {"Spinlock": "https://en.wikipedia.org/wiki/Spinlock"},
        {"Busy waiting": "https://en.wikipedia.org/wiki/Busy_waiting"}
      ]
    },
    {
      "question": "Spinlock의 단점은?",
      "choices": [
        "Busy waiting이 요구된다.",
        "멀티프로세서 시스템에 적절하지 않다.",
        "신뢰성이 떨어진다.",
        "구현이 매우 복잡하다."
      ],
      "answer": 1,
      "explanation": "Spinlock은 진입이 가능할 때까지 진입을 계속하여 시도하는 busy waiting lock입니다. 따라서 대기시간이 짧다면 context switching없이 critical section에 진입할 수 있어 효율적이지만, 프로세서가 적을 때 사용되면 다른 프로세스를 방해할 가능성이 커진다는 단점이 있습니다.",
      "references": [
        {"[한] Spinlock": "https://ko.wikipedia.org/wiki/%EC%8A%A4%ED%95%80%EB%9D%BD"},
        {"Spinlock": "https://en.wikipedia.org/wiki/Spinlock"},
        {"Busy waiting": "https://en.wikipedia.org/wiki/Busy_waiting"}
      ]
    },
    {
      "question": "Counting semaphore의 wait operation은 ___ 시스템 콜을 이용해 구현된다.",
      "choices": [
        "Stop",
        "Block",
        "Hold",
        "Wait"
      ],
      "answer": 2,
      "explanation": "Semaphore는 자원을 요청할 때 불리는 wait와 자원이 해제될 때 불리는 signal operation이 있습니다. 이 때 wait를 부른 프로세스는 semaphore queue에서 자원을 기다리는 blocked state가 되어야하므로 block 시스템 콜이 불립니다.",
      "references": [
        {"[한] Semaphore": "https://ko.wikipedia.org/wiki/%EC%84%B8%EB%A7%88%ED%8F%AC%EC%96%B4"},
        {"Semaphore": "https://en.wikipedia.org/wiki/Semaphore_(programming)"}
      ]
    },
    {
      "question": "만약 queue를 이용해 구현된 세마포어의 값이 음수라면, ___",
      "choices": [
        "비정상적인 경우이다.",
        "Signal operation이 있을 때까지 다른 작업을 할 수 없는 상태이다.",
        "임계 구역 (critical section) 에 진입하기 위해 대기 중인 프로세스가 있는 상태이다.",
        "Blocked였던 프로세스가 ready queue로 옮겨지는 상황이다."
      ],
      "answer": 3,
      "explanation": "우선 busy waiting이 아니라 queue를 이용해 프로세스의 상태를 관리하므로 요청한 프로세스가 대기하는 동안 다른 작업을 할 수 있어 2번은 틀린 내용이 됩니다. 4번은 signal operation 시에 세마포어가 음수일 때의 동작입니다.",
      "references": [
        {"[한] Semaphore": "https://ko.wikipedia.org/wiki/%EC%84%B8%EB%A7%88%ED%8F%AC%EC%96%B4"},
        {"Semaphore": "https://en.wikipedia.org/wiki/Semaphore_(programming)"}
      ]
    }
  ]
}
