{
  "questions": [
    {
      "question": "자식 프로세스를 부모 자원의 부분 집합으로 제한하는 것은 어떤 프로세스가 ___ 것을 방지하기 위함이다.",
      "choices": [
        "많은 보조 기억 장치를 사용함으로써 시스템에 부하를 만드는",
        "매우 낮은 CPU 활용도로 시스템에 적게 부하를 주는",
        "많은 서브프로세스를 만듦으로써 시스템에 부하를 주는",
        "많은 자원을 활용함으로써 시스템에 장애를 주는"
      ],
      "answer": 3,
      "explanation": "-",
      "references": [
        {"[한] Process": "https://ko.wikipedia.org/wiki/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4"},
        {"Process": "https://en.wikipedia.org/wiki/Process_(computing)"}
      ]
    },
    {
      "question": "___ 시스템 콜을 부르는 부모 프로세스는 자식 프로세스들이 종료될 때까지 정지된다.",
      "choices": [
        "wait",
        "fork",
        "exit",
        "exec"
      ],
      "answer": 1,
      "explanation": "-",
      "references": [
        {"wait": "https://en.wikipedia.org/wiki/Wait_(system_call)"},
        {"fork": "https://en.wikipedia.org/wiki/Fork_(system_call)"},
        {"exit": "https://en.wikipedia.org/wiki/Exit_(system_call)"}
      ]
    },
    {
      "question": "모든 자식 프로세스가 종료된 뒤에 부모 프로세스를 종료하는 것을 ___라 한다.",
      "choices": [
        "Normal termination",
        "Abnormal termination",
        "Cascading termination",
        "Circular termination"
      ],
      "answer": 3,
      "explanation": "부모에서 생성된 자식 프로세스들부터 종료되는 것이 프로세스 트리 (process tree) 구조 상 순차에 맞기에 cascading이라 합니다."
    },
    {
      "question": "___는 한 프로세서에서 다른 모든 프로세스를 대기시키면서 한 번에 오직 하나의 프로세스만 실행시키는 반면, ___는 여러 프로세스를 동시에 다른 프로세서에서 실행시킬 수 있다.",
      "choices": [
        "Multiprocessing, Multiprogramming",
        "Multiprogramming, Uniprocessing",
        "Multiprogramming, Multiprocessing",
        "Uniprogramming, Multiprocessing"
      ],
      "answer": 4,
      "explanation": "-",
      "references": [
        {"Multitasking": "https://en.wikipedia.org/wiki/Computer_multitasking"},
        {"Uniprocessor system": "https://en.wikipedia.org/wiki/Uniprocessor_system"}
      ]
    },
    {
      "question": "각 프로세스는 ___로 식별할 수 있다.",
      "choices": [
        "Process Control Block",
        "Device Queue",
        "Process Identifier",
        "모두 해당 안됨"
      ],
      "answer": 3,
      "explanation": "Process Identifier는 프로세스 식별자라는 의미로 PID라고 줄여씁니다.",
      "references": [
        {"[한] Process": "https://ko.wikipedia.org/wiki/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4"},
        {"Process": "https://en.wikipedia.org/wiki/Process_(computing)"}
      ]
    },
    {
      "question": "UNIX의 'fork' system call은 자식 프로세스에는 ___를 반환하고 부모 프로세스에는 ___를 반환한다.",
      "choices": [
        "음수, 0",
        "0, 음수",
        "양수, 0",
        "0, 양수"
      ],
      "answer": 4,
      "explanation": "fork는 부모 프로세스에게만 자식 프로세스의 PID를 반환하는 함수로, 자식 프로세스에는 아무것도 의미하지않는 0이 반환됩니다.",
      "references": [{"fork": "https://en.wikipedia.org/wiki/Fork_(system_call)"}]
    },
    {
      "question": "자식 프로세스가 수행을 마쳤을 때 부모 프로세스가 실행 중이라면 자식 프로세스는 ___가 된다.",
      "choices": [
        "고아 프로세스 (Orphan)",
        "좀비 프로세스 (Zombie)",
        "부모 프로세스",
        "죽은 프로세스"
      ],
      "answer": 2,
      "explanation": "좀비 프로세스가 된 자식 프로세스는 terminated 상태로 프로세스 테이블에 남아있다가 'wait' 시스템 콜이 호출됐을 때 제거됩니다.",
      "references": [
        {"Zombie process": "https://en.wikipedia.org/wiki/Zombie_process"},
        {"Orphan process": "https://en.wikipedia.org/wiki/Orphan_process"}
      ]
    },
    {
      "question": "다음 중 프로세스를 위한 queue가 아닌 것은?",
      "choices": [
        "Job Queue",
        "PCB Queue",
        "Device Queue",
        "Ready Queue"
      ],
      "answer": 2,
      "explanation": "PCB는 OS에 의해 pool로 관리되며 queue가 아닙니다.",
      "references": [
        {"PCB": "https://en.wikipedia.org/wiki/Process_control_block"}
      ]
    },
    {
      "question": "프로세스가 I/O를 요청했을 때 ___에 배치된다.",
      "choices": [
        "Job queue",
        "Waiting queue",
        "Ready queue",
        "Secondary storage"
      ],
      "answer": 2,
      "explanation": "-",
      "references": [{"Process state" : "https://en.wikipedia.org/wiki/Process_state"}]
    },
    {
      "question": "프로세스가 종료될 때 발생하는 일은?",
      "choices": [
        "모든 queue에서 삭제된다.",
        "Job queue를 제외한 queue에서 삭제된다.",
        "PCB의 메모리 할당이 해제된다.",
        "자식 프로세스를 강제로 종료시킨다."
      ],
      "answer": 1,
      "explanation": "PCB는 OS에서 풀 (pool) 을 이용해 관리하는 자원으로, 프로세스 종료 시 풀로 돌아가는 것이고 할당이 해제되는 것은 아닙니다. 자식 프로세스는 강제로 종료되지않기에 고아 프로세스가 발생할 수 있습니다.",
      "references": [
        {"[한] Process": "https://ko.wikipedia.org/wiki/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4"},
        {"Process": "https://en.wikipedia.org/wiki/Process_(computing)"}
      ]
    },
    {
      "question": "Long-term scheduler란?",
      "choices": [
        "ready queue에 옮겨질 프로세스를 선택한다.",
        "waiting queue에 옮겨질 프로세스를 선택한다.",
        "다음에 CPU를 할당받고 실행될 프로세스를 선택한다.",
        "메모리에서 스왑되어 제거될 프로세스를 선택한다."
      ],
      "answer": 1,
      "explanation": "Long-term scheduler는 실행되는 프로세스들이 I/O bound인지 CPU bound인지 파악하고 적절하게 ready queue에 배치함으로써 the degree of multiprogramming, 즉 병렬도를 향상시키기 위한 스케줄을 합니다.",
      "references": [
        {"Long-term scheduler": "https://en.wikipedia.org/wiki/Scheduling_(computing)#Long-term_scheduling"}
      ]
    },
    {
      "question": "만약 모든 프로세스가 I/O bound라면 ready queue는 거의 항상 ___ short-term scheduler는 할 일이 ___",
      "choices": [
        "꽉 차있고, 적다",
        "꽉 차있고, 많다",
        "비어있고, 적다",
        "비어있고, 많다"
      ],
      "answer": 3,
      "explanation": "프로세스가 I/O bound라면 I/O에 시간을 많이 쓰는 것이므로 ready보다 waiting queue에 있을 확률이 높다고 생각할 수 있습니다. 따라서 다음에 CPU를 할당받을 프로세스를 선택하는 short-term scheduler 입장에서는 할 일이 적어집니다.",
      "references": [
        {"Short-term scheduler": "https://en.wikipedia.org/wiki/Scheduling_(computing)#Short-term_scheduling"}
      ]
    },
    {
      "question": "Medium-term scheduler란?",
      "choices": [
        "ready queue에 옮겨질 프로세스를 선택한다.",
        "waiting queue에 옮겨질 프로세스를 선택한다.",
        "다음에 CPU를 할당받고 실행될 프로세스를 선택한다.",
        "메모리에서 스왑되어 제거될 프로세스를 선택한다."
      ],
      "answer": 4,
      "explanation": "Medium-term scheduler는 메모리 효율을 위해 오래동안 사용되지않은 프로세스를 메모리에서 HDD 등 secondary memory에 옮기거나, 빈번하게 page fault를 발생시키는 프로세스를 메인 메모리에 유지시키는 등 프로세스의 메모리 스왑 여부를 결정하는 스케줄러입니다.",
      "references": [
        {"Medium-term scheduler": "https://en.wikipedia.org/wiki/Scheduling_(computing)#Medium-term_scheduling"}
      ]
    },
    {
      "question": "Short-term scheduler란?",
      "choices": [
        "ready queue에 옮겨질 프로세스를 선택한다.",
        "waiting queue에 옮겨질 프로세스를 선택한다.",
        "다음에 CPU를 할당받고 실행될 프로세스를 선택한다.",
        "메모리에서 스왑되어 제거될 프로세스를 선택한다."
      ],
      "answer": 3,
      "explanation": "-",
      "references": [
        {"Short-term scheduler": "https://en.wikipedia.org/wiki/Scheduling_(computing)#Short-term_scheduling"}
      ]
    },
    {
      "question": "Short-term scheduler와 Long-term scheduler의 주된 차이점은?",
      "choices": [
        "queue 길이의 차이",
        "스케줄되는 프로세스 타입의 차이",
        "스케줄러의 실행 주기",
        "스케줄링에 소모되는 시간"
      ],
      "answer": 3,
      "explanation": "이름에서 알 수 있듯이 term은 스케줄러의 주기를 나타냅니다. 주기가 짧을수록 빈번하게 실행됩니다.\n실행 주기 : Long-term scheduler > Medium-term scheduler > Short-term scheduler",
      "references": [
        {"Scheduling": "https://en.wikipedia.org/wiki/Scheduling_(computing)"},
        {"Short-term scheduler": "https://en.wikipedia.org/wiki/Scheduling_(computing)#Short-term_scheduling"},
        {"Long-term scheduler": "https://en.wikipedia.org/wiki/Scheduling_(computing)#Long-term_scheduling"}
      ]
    },
    {
      "question": "유저 프로세스 스스로에 의한 상태 전이 (state transition) 는 ___가 유일하다.",
      "choices": [
        "block",
        "wakeup",
        "dispatch",
        "running"
      ],
      "answer": 1,
      "explanation": "wakeup과 dispatch는 스케줄러에 의해 행해집니다.",
      "references": [{"Blocked": "https://en.wikipedia.org/wiki/Process_state#Blocked"}]
    },
    {
      "question": "Time-sharing OS에서는 프로세스에 주어졌던 time slot이 완료되었을 때, 프로세스를 running 상태에서 ___ 상태로 전환시킨다.",
      "choices": [
        "Blocked",
        "Ready",
        "Suspended",
        "Terminated"
      ],
      "answer": 2,
      "explanation": "-",
      "references": [{"TSOS": "https://en.wikipedia.org/wiki/Time_Sharing_Operating_System"}]
    },
    {
      "question": "Multiprogramming 환경에서는 ___",
      "choices": [
        "프로세서가 한 번에 한 개 이상의 프로세스를 실행한다.",
        "프로그램이 한 명 이상의 사람에 의해 개발된다.",
        "한 개 이상의 프로세스가 메모리에 존재한다.",
        "한 명의 유저가 동시에 여러 프로그램을 실행시킬 수 있다."
      ],
      "answer": 3,
      "explanation": "-",
      "references": [{"Multiprogramming": "https://owd.tcnj.edu/~coburn/os"}]
    },
    {
      "question": "프로세스가 I/O 서비스를 기다리기위해 blocked state가 되었었다면, I/O 서비스가 완료되었을 때 프로세스는 어떤 상태가 되는가?",
      "choices": [
        "Running state",
        "Ready state",
        "Suspended state",
        "Terminated state"
      ],
      "answer": 2,
      "explanation": "-",
      "references": [{"Process state": "https://en.wikipedia.org/wiki/Process_state"}]
    },
    {
      "question": "PCB가 포함하지않는 것은?",
      "choices": [
        "CPU 레지스터의 값",
        "프로세스 상태 (Process state)",
        "메모리 관리 정보",
        "컨텍스트 스위치 (Context switch) 시간"
      ],
      "answer": 4,
      "explanation": "-",
      "references": [
        {"PCB": "https://en.wikipedia.org/wiki/Process_control_block"},
        {"Context switch": "https://en.wikipedia.org/wiki/Context_switch"}
      ]
    },
    {
      "question": "컨텍스트 스위칭 시에 필수적으로 저장될 필요가 없는 것은?",
      "choices": [
        "General purpose registers (GPR)",
        "Translation lookaside buffer (TLB)",
        "Program counter",
        "Page table"
      ],
      "answer": 2,
      "explanation": "Translation lookaside buffer (TLB) 는 페이지 테이블에 빠르게 접근하기위한 캐시로 memory management unit (MMU) 에서 하드웨어 레벨로 구현됩니다.",
      "references": [
        {"Context switch": "https://en.wikipedia.org/wiki/Context_switch"},
        {"PCB": "https://en.wikipedia.org/wiki/Process_control_block"},
        {"TLB": "https://en.wikipedia.org/wiki/Translation_lookaside_buffer"}
      ]
    },
    {
      "question": "다음 중 실행 중인 프로세스를 interrupt 하지않는 것은?",
      "choices": [
        "외부 장치",
        "Timer",
        "스케줄러 프로세스",
        "Power failure"
      ],
      "answer": 3,
      "explanation": "외부 장치와 Power 등 외부 요소는 I/O interrupt를 발생시킵니다. 반면 스케줄러 프로세스는 timer에 의해 trigger되는 프로세스로 다음에 실행될 프로세스를 선택할 뿐 실행 중인 프로세스를 직접적으로 interrupt하지는 않습니다.",
      "references": [
        {"[한] Interrupt": "https://ko.wikipedia.org/wiki/%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8"},
        {"Interrupt": "https://en.wikipedia.org/wiki/Interrupt"}
      ]
    }
  ]
}
