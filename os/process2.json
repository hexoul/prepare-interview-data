{
  "questions": [
    {
      "question": "자식 프로세스를 부모 자원의 부분 집합으로 제한하는 것은 어떤 프로세스가 ___ 것을 방지하기 위함이다.",
      "choices": [
        "많은 보조 기억 장치를 사용함으로써 시스템에 부하를 만드는",
        "매우 낮은 CPU 활용도로 시스템에 적게 부하를 주는",
        "많은 서브프로세스를 만듦으로써 시스템에 부하를 주는",
        "많은 자원을 활용함으로써 시스템에 장애를 주는"
      ],
      "answer": 3,
      "explanation": "-",
      "references": [
        {"[한] Process": "https://ko.wikipedia.org/wiki/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4"},
        {"Process": "https://en.wikipedia.org/wiki/Process_(computing)"}
      ]
    },
    {
      "question": "___ 시스템 콜을 부르는 부모 프로세스는 자식 프로세스들이 종료될 때까지 정지된다.",
      "choices": [
        "wait",
        "fork",
        "exit",
        "exec"
      ],
      "answer": 1,
      "explanation": "-",
      "references": [
        {"wait": "https://en.wikipedia.org/wiki/Wait_(system_call)"},
        {"fork": "https://en.wikipedia.org/wiki/Fork_(system_call)"},
        {"exit": "https://en.wikipedia.org/wiki/Exit_(system_call)"}
      ]
    },
    {
      "question": "모든 자식 프로세스가 종료된 뒤에 부모 프로세스를 종료하는 것을 ___라 한다.",
      "choices": [
        "Normal termination",
        "Abnormal termination",
        "Cascading termination",
        "Circular termination"
      ],
      "answer": 3,
      "explanation": "부모에서 생성된 자식 프로세스들부터 종료되는 것이 프로세스 트리 (process tree) 구조 상 순차에 맞기에 cascading이라 합니다."
    },
    {
      "question": "___는 한 프로세서에서 다른 모든 프로세스를 대기시키면서 한 번에 오직 하나의 프로세스만 실행시키는 반면, ___는 여러 프로세스를 동시에 다른 프로세서에서 실행시킬 수 있다.",
      "choices": [
        "Multiprocessing, Multiprogramming",
        "Multiprogramming, Uniprocessing",
        "Multiprogramming, Multiprocessing",
        "Uniprogramming, Multiprocessing"
      ],
      "answer": 4,
      "explanation": "-",
      "references": [
        {"Multitasking": "https://en.wikipedia.org/wiki/Computer_multitasking"},
        {"Uniprocessor system": "https://en.wikipedia.org/wiki/Uniprocessor_system"}
      ]
    },
    {
      "question": "각 프로세스는 ___로 식별할 수 있다.",
      "choices": [
        "Process Control Block",
        "Device Queue",
        "Process Identifier",
        "모두 해당 안됨"
      ],
      "answer": 3,
      "explanation": "Process Identifier는 프로세스 식별자라는 의미로 PID라고 줄여씁니다.",
      "references": [
        {"[한] Process": "https://ko.wikipedia.org/wiki/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4"},
        {"Process": "https://en.wikipedia.org/wiki/Process_(computing)"}
      ]
    },
    {
      "question": "UNIX의 'fork' system call은 자식 프로세스에는 ___를 반환하고 부모 프로세스에는 ___를 반환한다.",
      "choices": [
        "음수, 0",
        "0, 음수",
        "양수, 0",
        "0, 양수"
      ],
      "answer": 4,
      "explanation": "fork는 부모 프로세스에게만 자식 프로세스의 PID를 반환하는 함수로, 자식 프로세스에는 아무것도 의미하지않는 0이 반환됩니다.",
      "references": [{"fork": "https://en.wikipedia.org/wiki/Fork_(system_call)"}]
    },
    {
      "question": "자식 프로세스가 수행을 마쳤을 때 부모 프로세스가 실행 중이라면 자식 프로세스는 ___가 된다.",
      "choices": [
        "고아 프로세스 (Orphan)",
        "좀비 프로세스 (Zombie)",
        "부모 프로세스",
        "죽은 프로세스"
      ],
      "answer": 2,
      "explanation": "좀비 프로세스가 된 자식 프로세스는 terminated 상태로 프로세스 테이블에 남아있다가 'wait' 시스템 콜이 호출됐을 때 제거됩니다.",
      "references": [
        {"Zombie process": "https://en.wikipedia.org/wiki/Zombie_process"},
        {"Orphan process": "https://en.wikipedia.org/wiki/Orphan_process"}
      ]
    },
    {
      "question": "다음 중 프로세스를 위한 queue가 아닌 것은?",
      "choices": [
        "Job Queue",
        "PCB Queue",
        "Device Queue",
        "Ready Queue"
      ],
      "answer": 2,
      "explanation": "PCB는 OS에 의해 pool로 관리되며 queue가 아닙니다.",
      "references": [
        {"PCB": "https://en.wikipedia.org/wiki/Process_control_block"}
      ]
    },
    {
      "question": "프로세스가 I/O를 요청했을 때 ___에 배치된다.",
      "choices": [
        "Job queue",
        "Waiting queue",
        "Ready queue",
        "Secondary storage"
      ],
      "answer": 2,
      "explanation": "-",
      "references": [{"Process state" : "https://en.wikipedia.org/wiki/Process_state"}]
    },
    {
      "question": "프로세스가 종료될 때 발생하는 일은?",
      "choices": [
        "모든 queue에서 삭제된다.",
        "Job queue를 제외한 queue에서 삭제된다.",
        "PCB의 메모리 할당이 해제된다.",
        "자식 프로세스를 강제로 종료시킨다."
      ],
      "answer": 1,
      "explanation": "PCB는 OS에서 풀 (pool) 을 이용해 관리하는 자원으로, 프로세스 종료 시 풀로 돌아가는 것이고 할당이 해제되는 것은 아닙니다. 자식 프로세스는 강제로 종료되지않기에 고아 프로세스가 발생할 수 있습니다.",
      "references": [
        {"[한] Process": "https://ko.wikipedia.org/wiki/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4"},
        {"Process": "https://en.wikipedia.org/wiki/Process_(computing)"}
      ]
    },
    {
      "question": "Long-term scheduler란?",
      "choices": [
        "ready queue에 옮겨질 프로세스를 선택한다.",
        "waiting queue에 옮겨질 프로세스를 선택한다.",
        "다음에 CPU를 할당받고 실행될 프로세스를 선택한다.",
        "메모리에서 스왑되어 제거될 프로세스를 선택한다."
      ],
      "answer": 1,
      "explanation": "Long-term scheduler는 실행되는 프로세스들이 I/O bound인지 CPU bound인지 파악하고 적절하게 ready queue에 배치함으로써 the degree of multiprogramming, 즉 병렬도를 향상시키기 위한 스케줄을 합니다.",
      "references": [
        {"Long-term scheduler": "https://en.wikipedia.org/wiki/Scheduling_(computing)#Long-term_scheduling"}
      ]
    },
    {
      "question": "만약 모든 프로세스가 I/O bound라면 ready queue는 거의 항상 ___ short-term scheduler는 할 일이 ___",
      "choices": [
        "꽉 차있고, 적다",
        "꽉 차있고, 많다",
        "비어있고, 적다",
        "비어있고, 많다"
      ],
      "answer": 3,
      "explanation": "프로세스가 I/O bound라면 I/O에 시간을 많이 쓰는 것이므로 ready보다 waiting queue에 있을 확률이 높다고 생각할 수 있습니다. 따라서 다음에 CPU를 할당받을 프로세스를 선택하는 short-term scheduler 입장에서는 할 일이 적어집니다.",
      "references": [
        {"Short-term scheduler": "https://en.wikipedia.org/wiki/Scheduling_(computing)#Short-term_scheduling"}
      ]
    },
    {
      "question": "Medium-term scheduler란?",
      "choices": [
        "ready queue에 옮겨질 프로세스를 선택한다.",
        "waiting queue에 옮겨질 프로세스를 선택한다.",
        "다음에 CPU를 할당받고 실행될 프로세스를 선택한다.",
        "메모리에서 스왑되어 제거될 프로세스를 선택한다."
      ],
      "answer": 4,
      "explanation": "Medium-term scheduler는 메모리 효율을 위해 오래동안 사용되지않은 프로세스를 메모리에서 HDD 등 secondary memory에 옮기거나, 빈번하게 page fault를 발생시키는 프로세스를 메인 메모리에 유지시키는 등 프로세스의 메모리 스왑 여부를 결정하는 스케줄러입니다.",
      "references": [
        {"Medium-term scheduler": "https://en.wikipedia.org/wiki/Scheduling_(computing)#Medium-term_scheduling"}
      ]
    },
    {
      "question": "Short-term scheduler란?",
      "choices": [
        "ready queue에 옮겨질 프로세스를 선택한다.",
        "waiting queue에 옮겨질 프로세스를 선택한다.",
        "다음에 CPU를 할당받고 실행될 프로세스를 선택한다.",
        "메모리에서 스왑되어 제거될 프로세스를 선택한다."
      ],
      "answer": 3,
      "explanation": "-",
      "references": [
        {"Short-term scheduler": "https://en.wikipedia.org/wiki/Scheduling_(computing)#Short-term_scheduling"}
      ]
    },
    {
      "question": "Short-term scheduler와 Long-term scheduler의 주된 차이점은?",
      "choices": [
        "queue 길이의 차이",
        "스케줄되는 프로세스 타입의 차이",
        "스케줄러의 실행 주기",
        "스케줄링에 소모되는 시간"
      ],
      "answer": 3,
      "explanation": "이름에서 알 수 있듯이 term은 스케줄러의 주기를 나타냅니다. 주기가 짧을수록 빈번하게 실행됩니다.\n실행 주기 : Long-term scheduler > Medium-term scheduler > Short-term scheduler",
      "references": [
        {"Scheduling": "https://en.wikipedia.org/wiki/Scheduling_(computing)"},
        {"Short-term scheduler": "https://en.wikipedia.org/wiki/Scheduling_(computing)#Short-term_scheduling"},
        {"Long-term scheduler": "https://en.wikipedia.org/wiki/Scheduling_(computing)#Long-term_scheduling"}
      ]
    },
    {
      "question": "유저 프로세스 스스로에 의한 상태 전이 (state transition) 는 ___가 유일하다.",
      "choices": [
        "block",
        "wakeup",
        "dispatch",
        "running"
      ],
      "answer": 1,
      "explanation": "wakeup과 dispatch는 스케줄러에 의해 행해집니다.",
      "references": [{"Blocked": "https://en.wikipedia.org/wiki/Process_state#Blocked"}]
    },
    {
      "question": "Time-sharing OS에서는 프로세스에 주어졌던 time slot이 완료되었을 때, 프로세스를 running 상태에서 ___ 상태로 전환시킨다.",
      "choices": [
        "Blocked",
        "Ready",
        "Suspended",
        "Terminated"
      ],
      "answer": 2,
      "explanation": "-",
      "references": [{"TSOS": "https://en.wikipedia.org/wiki/Time_Sharing_Operating_System"}]
    },
    {
      "question": "Multiprogramming 환경에서는 ___",
      "choices": [
        "프로세서가 한 번에 한 개 이상의 프로세스를 실행한다.",
        "프로그램이 한 명 이상의 사람에 의해 개발된다.",
        "한 개 이상의 프로세스가 메모리에 존재한다.",
        "한 명의 유저가 동시에 여러 프로그램을 실행시킬 수 있다."
      ],
      "answer": 3,
      "explanation": "-",
      "references": [{"Multiprogramming": "https://owd.tcnj.edu/~coburn/os"}]
    },
    {
      "question": "프로세스가 I/O 서비스를 기다리기위해 blocked state가 되었었다면, I/O 서비스가 완료되었을 때 프로세스는 어떤 상태가 되는가?",
      "choices": [
        "Running state",
        "Ready state",
        "Suspended state",
        "Terminated state"
      ],
      "answer": 2,
      "explanation": "-",
      "references": [{"Process state": "https://en.wikipedia.org/wiki/Process_state"}]
    },
    {
      "question": "PCB가 포함하지않는 것은?",
      "choices": [
        "CPU 레지스터의 값",
        "프로세스 상태 (Process state)",
        "메모리 관리 정보",
        "컨텍스트 스위치 (Context switch) 시간"
      ],
      "answer": 4,
      "explanation": "-",
      "references": [
        {"PCB": "https://en.wikipedia.org/wiki/Process_control_block"},
        {"Context switch": "https://en.wikipedia.org/wiki/Context_switch"}
      ]
    },
    {
      "question": "컨텍스트 스위칭 시에 필수적으로 저장될 필요가 없는 것은?",
      "choices": [
        "General purpose registers (GPR)",
        "Translation lookaside buffer (TLB)",
        "Program counter",
        "Page table"
      ],
      "answer": 2,
      "explanation": "Translation lookaside buffer (TLB) 는 페이지 테이블에 빠르게 접근하기위한 캐시로 memory management unit (MMU) 에서 하드웨어 레벨로 구현됩니다.",
      "references": [
        {"Context switch": "https://en.wikipedia.org/wiki/Context_switch"},
        {"PCB": "https://en.wikipedia.org/wiki/Process_control_block"},
        {"TLB": "https://en.wikipedia.org/wiki/Translation_lookaside_buffer"}
      ]
    },
    {
      "question": "다음 중 실행 중인 프로세스를 interrupt 하지않는 것은?",
      "choices": [
        "외부 장치",
        "Timer",
        "스케줄러 프로세스",
        "Power failure"
      ],
      "answer": 3,
      "explanation": "외부 장치와 Power 등 외부 요소는 I/O interrupt를 발생시킵니다. 반면 스케줄러 프로세스는 timer에 의해 trigger되는 프로세스로 다음에 실행될 프로세스를 선택할 뿐 실행 중인 프로세스를 직접적으로 interrupt하지는 않습니다.",
      "references": [
        {"[한] Interrupt": "https://ko.wikipedia.org/wiki/%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8"},
        {"Interrupt": "https://en.wikipedia.org/wiki/Interrupt"}
      ]
    },
    {
      "question": "프로세스가 시작해서 끝날 때까지의 시간을 뜻하는 용어는?",
      "choices": [
        "응답 시간 (Response time)",
        "대기 시간 (Waiting time)",
        "반환 시간 (Turnaround time)",
        "처리량 (Throughput)"
      ],
      "answer": 3,
      "explanation": "-",
      "references": [
        {"Response time": "https://en.wikipedia.org/wiki/Response_time_(technology)"},
        {"Turnaround time (TAT)": "https://en.wikipedia.org/wiki/Turnaround_time"},
        {"Throughput": "https://en.wikipedia.org/wiki/Throughput"}
      ]
    },
    {
      "question": "처음으로 CPU를 요청한 프로세스가 처음으로 CPU를 할당받는 스케줄링 알고리즘은?",
      "choices": [
        "First Come First Serve (FCFS) scheduling",
        "Shortest Job First (SJF) scheduling",
        "Priority scheduling",
        "Round-robin scheduling"
      ],
      "answer": 1,
      "explanation": "FCFS (혹은 FIFO) 는 단어 뜻 그대로 요청된 순서대로 처리되는 알고리즘입니다. 보통 queue를 이용해 구현됩니다.",
      "references": [
        {"FCFS": "https://en.wikipedia.org/wiki/FIFO_(computing_and_electronics)"},
        {"SJF": "https://en.wikipedia.org/wiki/Shortest_job_next"},
        {"Priority scheduling": "https://en.wikipedia.org/wiki/Scheduling_(computing)#Priority_scheduling"},
        {"Round-robin (RR)": "https://en.wikipedia.org/wiki/Round-robin_scheduling"}
      ]
    },
    {
      "question": "CPU 제어권을 Short-term 스케줄러에 의해 선택된 프로세스에게 넘겨주는 모듈은?",
      "choices": [
        "interrupt",
        "scheduler",
        "dispatcher",
        "fetcher"
      ],
      "answer": 3,
      "explanation": "-",
      "references": [
        {"Dispatcher": "https://en.wikipedia.org/wiki/Scheduling_(computing)#Dispatcher"}
      ]
    },
    {
      "question": "Priority 스케줄링 알고리즘에 대한 설명으로 맞는 것은?",
      "choices": [
        "가장 높은 우선순위를 가진 프로세스에 CPU를 할당한다.",
        "가장 낮은 우선순위를 가진 프로세스에 CPU를 할당한다.",
        "동일한 우선순위를 가진 프로세스들은 스케줄될 수 없다.",
        "Queue에 빨리 들어온 프로세스가 높은 우선순위를 가진다."
      ],
      "answer": 1,
      "explanation": "Priority 스케줄링 알고리즘은 높은 우선순위를 가진 프로세스에 먼저 CPU를 할당하며, 동일한 우선순위를 가진 프로세스가 2개 이상 있다면 임의로 그 중 하나를 선택합니다. 스케줄이 안되는 경우는 없습니다. Priority는 직접 입력을 받기도 하지만 특성에 따라 산정되기도 합니다. 예로 RTOS에서는 데드라인이 짧을수록 우선순위가 높은 EDF 등이 있습니다.",
      "references": [
        {"Priority scheduling": "https://en.wikipedia.org/wiki/Scheduling_(computing)#Priority_scheduling"},
        {"EDF": "https://en.wikipedia.org/wiki/Earliest_deadline_first_scheduling"}
      ]
    },
    {
      "question": "다음 중 내부적으로 time quantum을 정의하는 알고리즘은?",
      "choices": [
        "Shortest Job First (SJF) scheduling",
        "Round-robin (RR) scheduling",
        "Priority scheduling",
        "Multilevel queue scheduling"
      ],
      "answer": 2,
      "explanation": "Round-robin은 모든 프로세스를 우선순위없이 동등하게 실행시키기위해 time slice (혹은 time quantum) 만큼 각 프로세스에 CPU를 할당하는 알고리즘입니다. 이러한 특성상 순환 실행 (cyclic executive) 이라고도 불립니다. 우선순위가 없기때문에 starvation-free를 구현하기 쉬워집니다.",
      "references": [
        {"SJF": "https://en.wikipedia.org/wiki/Shortest_job_next"},
        {"Priority scheduling": "https://en.wikipedia.org/wiki/Scheduling_(computing)#Priority_scheduling"},
        {"Round-robin (RR)": "https://en.wikipedia.org/wiki/Round-robin_scheduling"},
        {"Multilevel queue": "https://en.wikipedia.org/wiki/Multilevel_queue"}
      ]
    },
    {
      "question": "Multilevel feedback queue 스케줄링 알고리즘에 대한 설명으로 맞는 것은?",
      "choices": [
        "프로세스는 다른 분류의 ready queue로 옮겨질 수 있다.",
        "프로세스는 분류되어지지 않는다.",
        "프로세스가 CPU bound라면 우선순위가 높아진다.",
        "많은 기아 (starvation) 가 발생할 수 있다."
      ],
      "answer": 1,
      "explanation": "Multilevel feeback queue 스케줄링 알고리즘에서는 피드백에 따라 프로세스들의 우선순위가 동적으로 바뀌고, 이에 따라 할당되는 queue도 변경됩니다. 예를 들어, CPU bound보다 I/O bound에 높은 우선순위를 줌으로써 기아 (starvation) 를 방지하는 데에도 도움을 줍니다.",
      "references": [
        {"Multilevel feedback queue": "https://en.wikipedia.org/wiki/Multilevel_feedback_queue"}
      ]
    },
    {
      "question": "다음 중 커널에 의해 스케줄되지 않는 것은?",
      "choices": [
        "Kernel-level thread",
        "User-level thread",
        "Process",
        "모두 해당 안됨"
      ],
      "answer": 2,
      "explanation": "User-level thread는 라이브러리를 통해 애플리케이션 레벨에서 관리와 스케줄이 행해지므로 커널이 인식하지 못합니다. User-level threading은 context switch를 필요로 하지 않기때문에 kernel-level threading에 비해 빠르다는 장점이 있습니다.",
      "references": [
        {"[한] Thread": "https://ko.wikipedia.org/wiki/%EC%8A%A4%EB%A0%88%EB%93%9C_(%EC%BB%B4%ED%93%A8%ED%8C%85)"},
        {"Thread": "https://en.wikipedia.org/wiki/Thread_(computing)"}
      ]
    },
    {
      "question": "Non-preemptive scheduling이 발생하는 경우는?",
      "choices": [
        "프로세스가 running state에서 ready state로 전이될 때",
        "프로세스가 running state에서 waiting state로 전이될 때",
        "프로세스가 waiting state에서 ready state로 전이될 때",
        "모두 해당 안됨"
      ],
      "answer": 2,
      "explanation": "비선점 (non-preemtpvie) 으로 스케줄링이 발생하려면 간섭이 없어야하므로 프로세스가 스스로 자원을 놓는 상태 전이가 있어야 합니다. 즉 I/O 요청 등으로 인해 block되어 waiting state로 전이될 때가 이에 해당합니다.",
      "references": [
        {"Preemption": "https://en.wikipedia.org/wiki/Preemption_(computing)"},
        {"Blocked": "https://en.wikipedia.org/wiki/Process_state#Blocked"}
      ]
    },
    {
      "question": "Dispatch latency란?",
      "choices": [
        "프로세스를 running state에서 ready state로 dispatching 하는 시간",
        "프로세스를 running state에서 ready state로 dispatching 하는 동안 CPU가 idle 이었던 시간",
        "Running state였던 프로세스를 멈추고 다른 프로세스를 running state로 만들 때까지 걸린 시간",
        "Dispatch 될 프로세스를 선택하는데 걸린 시간"
      ],
      "answer": 3,
      "explanation": "Dispatch latency는 우선순위가 더 높은 프로세스 (혹은 태스크 또는 스레드) 를 실행시키기위해 리스케줄 (reschedule) 하는 시간이라고도 볼 수 있습니다.",
      "references": [
        {"Dispatcher": "https://en.wikipedia.org/wiki/Scheduling_(computing)#Dispatcher"},
        {"Dispatch latency": "https://docs.oracle.com/cd/E19455-01/806-4750/chap7rt-21297/index.html"}
      ]
    },
    {
      "question": "Round-robin 스케줄링은 ___이다.",
      "choices": [
        "Non-preemptive",
        "Preemptive",
        "위에 언급된 모두 해당",
        "모두 해당 안됨"
      ],
      "answer": 2,
      "explanation": "Round-robin 스케줄링에서는 time slice (혹은 time quantum) 마다 CPU 할당이 바뀌어야하므로, 실행 중인 프로세스가 있었더라도 다음 프로세스에 선점되어야합니다.",
      "references": [
        {"Round-robin": "https://en.wikipedia.org/wiki/Round-robin_scheduling"}
      ]
    },
    {
      "question": "Round-robin 스케줄링 알고리즘에 대한 설명으로 맞는 것은?",
      "choices": [
        "Time slice가 매우 크다면 FCFS로 변환될 수 있다.",
        "Time slice가 매우 작다면 FCFS로 변환될 수 있다.",
        "Time slice가 매우 작다면 성능을 향상시킬 수 있다.",
        "Time slice가 매우 작다면 SJF로 변환될 수 있다."
      ],
      "answer": 1,
      "explanation": "Time slice가 매우 크다면 선점되는 일 없이 queue에 들어온 순서대로 처리될 것이므로 FCFS로 변환될 수 있습니다. Time slice가 작다면 불필요하게 빈번한 컨텍스트 스위치가 발생해 오버헤드가 커집니다.",
      "references": [
        {"Round-robin": "https://en.wikipedia.org/wiki/Round-robin_scheduling"},
        {"FCFS": "https://en.wikipedia.org/wiki/FIFO_(computing_and_electronics)"},
        {"Context switch": "https://en.wikipedia.org/wiki/Context_switch"}
      ]
    },
    {
      "question": "Idle time에 대한 설명으로 틀린 것은?",
      "choices": [
        "CPU가 busy가 아니었던 시간",
        "CPU가 idle task를 실행시킨 시간",
        "Kernel space에서 코드를 실행한 시간은 idle에 포함되지 않는다.",
        "Idle task는 외부에서 관측되지 않는다."
      ],
      "answer": 4,
      "explanation": "Kernel space나 user space 상관없이 idle task가 아닌 코드를 실행하고 있었다면 busy라고 보아야 합니다. Idle task는 OS 구현에 따라서 하드코딩되어있다면 관측되지 않을 수도 있지만 최하위 우선순위의 프로세스로 작성될 경우 관측 가능합니다.",
      "references": [
        {"Idle": "https://en.wikipedia.org/wiki/Idle_(CPU)"},
        {"CPU time": "https://en.wikipedia.org/wiki/CPU_time"}
      ]
    },
    {
      "question": "CPU time에 대한 설명으로 틀린 것은?",
      "choices": [
        "CPU time 중 user time은 사용자에 의해 CPU가 busy였던 시간이다.",
        "CPU time 중 system time은 kernel space에서 CPU가 busy였던 시간이다.",
        "CPU time은 user time과 system time의 합이다.",
        "멀티프로세서 시스템에서 CPU time은 각 코어의 CPU time을 합한 값이다."
      ],
      "answer": 1,
      "explanation": "User time은 user space에서 CPU가 busy였던 시간입니다. 사용자에 의해 실행된 프로세스는 user space에서 시작하지만, 시스템 콜을 호출하는 경우 kernel space에서 실행되는 부분도 생기기때문에 온전히 user space에서만 실행된다고 볼 수 없습니다.",
      "references": [
        {"CPU time": "https://en.wikipedia.org/wiki/CPU_time"}
      ]
    },
    {
      "question": "Priority 스케줄링 알고리즘의 단점은?",
      "choices": [
        "매우 복잡한 방법으로 스케줄한다.",
        "스케줄링에 많은 시간이 요구된다.",
        "낮은 우선순위의 프로세스는 CPU를 할당받지 못하고 무한하게 대기할 수도 있다.",
        "위에 언급된 모두 해당"
      ],
      "answer": 3,
      "explanation": "-",
      "references": [
        {"Priority scheduling": "https://en.wikipedia.org/wiki/Scheduling_(computing)#Priority_scheduling"}
      ]
    },
    {
      "question": "Aging이란?",
      "choices": [
        "캐시가 만료되지 않도록 유지하는 것",
        "페이지가 메모리에서 스왑되지 않도록 유지하는 것",
        "최근 실행된 프로세스의 우선순위를 낮추는 것",
        "오랫동안 수행되지 못하고 대기한 task의 우선순위를 높이는 것"
      ],
      "answer": 4,
      "explanation": "Priority 스케줄링 알고리즘에서는 낮은 우선순위를 가진 프로세스의 경우 기아가 발생해 무한히 대기할 수도 있습니다. 이러한 문제점을 해결하고자, 프로세스가 유한한 시간 내에 끝날 수 있도록 CPU 대기시간이 긴 task에 대해서 일시적으로 우선순위를 높이는 기법이 제안되었습니다. 이를 aging이라 합니다.",
      "references": [
        {"Aging": "https://en.wikipedia.org/wiki/Aging_(scheduling)"}
      ]
    }
  ]
}
