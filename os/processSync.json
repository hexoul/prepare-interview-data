{
  "questions": [
    {
      "question": "같은 프로세스에 의해 non-recursive mutex가 두 번 이상 lock 될 경우 발생하는 일은?",
      "choices": [
        "Starvation",
        "Deadlock",
        "Aging",
        "Signaling"
      ],
      "answer": 2,
      "explanation": "Non-recursive mutex는 재진입이 불가능한 mutex를 말합니다. 이 경우, 첫 lock에서는 mutex를 문제없이 취득하지만 두 번째 lock에서는 mutex를 놓지않은 채 재취득하려는 시도만 있기 때문에 오도 가도 못하는 상황이 되어 deadlock에 빠지게 됩니다.",
      "references": [
        {"Starvation": "https://en.wikipedia.org/wiki/Starvation_(computer_science)"},
        {"Deadlock": "https://en.wikipedia.org/wiki/Deadlock"},
        {"Aging": "https://en.wikipedia.org/wiki/Aging_(scheduling)"},
        {"Recursive mutex": "https://en.wikipedia.org/wiki/Reentrant_mutex"}
      ]
    },
    {
      "question": "세마포어란?",
      "choices": [
        "Binary mutex이다.",
        "오직 한 프로세스로부터만 접근되어야 한다.",
        "여러 프로세스로부터 접근될 수 있다.",
        "모두 해당 안됨"
      ],
      "answer": 3,
      "explanation": "-",
      "references": [
        {"[한] Semaphore": "https://ko.wikipedia.org/wiki/%EC%84%B8%EB%A7%88%ED%8F%AC%EC%96%B4"},
        {"Semaphore": "https://en.wikipedia.org/wiki/Semaphore_(programming)"}
      ]
    },
    {
      "question": "세마포어의 두 종류는?",
      "choices": [
        "mutex & counting",
        "binary & counting",
        "mutex & binary ",
        "spin & binary"
      ],
      "answer": 2,
      "explanation": "세마포어가 0 또는 1만 가리키는 것을 binary semaphore라 하고 이외에는 counting semaphore라 합니다.",
      "references": [
        {"[한] Semaphore": "https://ko.wikipedia.org/wiki/%EC%84%B8%EB%A7%88%ED%8F%AC%EC%96%B4"},
        {"Semaphore": "https://en.wikipedia.org/wiki/Semaphore_(programming)"}
      ]
    },
    {
      "question": "Mutex란?",
      "choices": [
        "Binary semaphore이다.",
        "오직 한 프로세스로부터만 접근되어야 한다.",
        "여러 프로세스로부터 접근될 수 있다.",
        "모두 해당 안됨"
      ],
      "answer": 2,
      "explanation": "Binary semaphore는 세마포어를 감소시켰던 프로세스가 아닌 다른 프로세스도 세마포어를 증가시킬 수 있는 것에 반해, mutex는 취득했던 프로세스 또는 쓰레드가 직접 해제해야 한다는 차이가 있습니다. 따라서 mutex는 binary semaphore와는 다르고 여러 프로세스 또는 쓰레드들로부터 접근되면 안됩니다.",
      "references": [
        {"Mutex": "https://en.wikipedia.org/wiki/Lock_(computer_science)"},
        {"Semaphore": "https://en.wikipedia.org/wiki/Semaphore_(programming)"}
      ]
    },
    {
      "question": "특정 시점에 counting semaphore의 값이 7이었다면, 20 번의 P operation과 15 번의 V operation 후에 값이 어떻게 변경되는가?",
      "choices": [
        "2",
        "7",
        "12",
        "42"
      ],
      "answer": 1,
      "explanation": "세마포어에서 P operation은 값을 1 감소시키는 wait operation에 해당하고, V operation은 값을 1 증가시키는 signal operation에 해당합니다. 따라서 7 - 20 + 15가 되어 답은 2가 됩니다.",
      "references": [
        {"[한] Semaphore": "https://ko.wikipedia.org/wiki/%EC%84%B8%EB%A7%88%ED%8F%AC%EC%96%B4"},
        {"Semaphore": "https://en.wikipedia.org/wiki/Semaphore_(programming)"}
      ]
    },
    {
      "question": "Bounded buffer problem은 ___라고도 알려져 있다.",
      "choices": [
        "Readers-writers (독자-저자) problem",
        "Producer-consumer (생산자-소비자) problem",
        "Dining philosophers (철학자들의 만찬) problem",
        "Sleeping barber (잠자는 이발사) problem"
      ],
      "answer": 2,
      "explanation": "-",
      "references": [
        {"[한] Readers-writers problem": "https://ko.wikipedia.org/wiki/%EB%8F%85%EC%9E%90-%EC%A0%80%EC%9E%90_%EB%AC%B8%EC%A0%9C"},
        {"Readers-writers problem": "https://en.wikipedia.org/wiki/Readers%E2%80%93writers_problem"},
        {"[한] Producer-consumer problem": "https://ko.wikipedia.org/wiki/%EC%83%9D%EC%82%B0%EC%9E%90-%EC%86%8C%EB%B9%84%EC%9E%90_%EB%AC%B8%EC%A0%9C"},
        {"Producer-consumer problem": "https://en.wikipedia.org/wiki/Producer%E2%80%93consumer_problem"},
        {"[한] Dining philosophers problem": "https://ko.wikipedia.org/wiki/%EC%8B%9D%EC%82%AC%ED%95%98%EB%8A%94_%EC%B2%A0%ED%95%99%EC%9E%90%EB%93%A4_%EB%AC%B8%EC%A0%9C"},
        {"Dining philosophers problem": "https://en.wikipedia.org/wiki/Dining_philosophers_problem"},
        {"[한] Sleeping barber problem": "https://ko.wikipedia.org/wiki/%EC%9E%A0%EC%9E%90%EB%8A%94_%EC%9D%B4%EB%B0%9C%EC%82%AC_%EB%AC%B8%EC%A0%9C"},
        {"Sleeping barber problem": "https://en.wikipedia.org/wiki/Sleeping_barber_problem"}
      ]
    },
    {
      "question": "Bounded buffer problem에 대한 설명으로 틀린 것은?",
      "choices": [
        "문제해결에 비어있는 버퍼와 사용될 수 있는 버퍼의 수에 대한 세마포어가 사용될 수 있다.",
        "유한한 N 개의 버퍼를 가지고 있다.",
        "세마포어만으로 이 문제를 완벽하게 해결할 수 있다.",
        "Producer가 아이템을 queue에 넣는 속도와 consumer가 queue에서 아이템을 빼는 속도가 같다면, bounded buffer problem은 발생하지 않는다."
      ],
      "answer": 3,
      "explanation": "Producer와 consumer가 각각 하나만 있다면 세마포어만으로 해결 가능합니다. 하지만 복수개의 producer 또는 consumer가 있다면 race condition으로부터 deadlock이 발생할 수 있습니다. 이 경우 문제해결에 mutex도 요구됩니다.",
      "references": [
        {"[한] Producer-consumer problem": "https://ko.wikipedia.org/wiki/%EC%83%9D%EC%82%B0%EC%9E%90-%EC%86%8C%EB%B9%84%EC%9E%90_%EB%AC%B8%EC%A0%9C"},
        {"Producer-consumer problem": "https://en.wikipedia.org/wiki/Producer%E2%80%93consumer_problem"}
      ]
    },
    {
      "question": "Readers-writers problem에서 ___는 공유 객체에 배타적으로 (exclusive) 접근해야 한다.",
      "choices": [
        "Reader",
        "Writer",
        "Reader and writer",
        "Process"
      ],
      "answer": 3,
      "explanation": "읽기 중에 쓰거나 쓰기 중에 읽는 경우 모두 inconsistency를 발생시킬 수 있으므로, reader와 writer 모두 공유 객체에 대해 배타적으로 접근해야 합니다.",
      "references": [
        {"[한] Reader-writer problem": "https://ko.wikipedia.org/wiki/%EB%8F%85%EC%9E%90-%EC%A0%80%EC%9E%90_%EB%AC%B8%EC%A0%9C"},
        {"Reader-writer problem": "https://en.wikipedia.org/wiki/Readers%E2%80%93writers_problem"}
      ]
    },
    {
      "question": "식사하는 철학자들 (Dining philosophers) 문제가 발생하는 경우는?",
      "choices": [
        "3명의 철학자들과 5개의 젓가락",
        "4명의 철학자들과 5개의 젓가락",
        "5명의 철학자들과 5개의 젓가락",
        "5명의 철학자들과 6개의 젓가락"
      ],
      "answer": 3,
      "explanation": "철학자의 수보다 젓가락의 수가 같거나 작으면 해당 문제가 발생할 수 있습니다. 젓가락이 한개라도 많고 자원에 접근하는 순서가 보장된다면 무한정 대기하는 상황에는 빠지지 않습니다.",
      "references": [
        {"[한] Dining philosophers problem": "https://ko.wikipedia.org/wiki/%EC%8B%9D%EC%82%AC%ED%95%98%EB%8A%94_%EC%B2%A0%ED%95%99%EC%9E%90%EB%93%A4_%EB%AC%B8%EC%A0%9C"},
        {"Dining philosophers problem": "https://en.wikipedia.org/wiki/Dining_philosophers_problem"}
      ]
    },
    {
      "question": "다음 중 식사하는 철학자들 (Dining philosophers) 문제의 해법이 아닌 것은?",
      "choices": [
        "Resource hierarchy solution",
        "Arbitrator solution",
        "Dijkstra's algorithmm",
        "Chandy–Misra–Haas algorithm"
      ],
      "answer": 3,
      "explanation": "Dijkstra's algorithm은 최단 경로를 찾는 알고리즘입니다. Resource hierarchy solution도 dijkstra에 의해 제안되었고 자원 간 경로를 기반으로 해결한다는 점에서 유사하게 보일 수 있으나, 최단 경로만으로는 이 문제를 해결할 수 없습니다.",
      "references": [
        {"[한] Dining philosophers problem": "https://ko.wikipedia.org/wiki/%EC%8B%9D%EC%82%AC%ED%95%98%EB%8A%94_%EC%B2%A0%ED%95%99%EC%9E%90%EB%93%A4_%EB%AC%B8%EC%A0%9C"},
        {"Dining philosophers problem": "https://en.wikipedia.org/wiki/Dining_philosophers_problem"},
        {"Resource hierarchy solution": "https://en.wikipedia.org/wiki/Dining_philosophers_problem#Resource_hierarchy_solution"},
        {"Arbitrator solution": "https://en.wikipedia.org/wiki/Dining_philosophers_problem#Resource_hierarchy_solution"},
        {"Dijkstra's algorithm": "https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm"},
        {"Chandy–Misra–Haas algorithm": "https://en.wikipedia.org/wiki/Chandy%E2%80%93Misra%E2%80%93Haas_algorithm_resource_model"}
      ]
    }
  ]
}
