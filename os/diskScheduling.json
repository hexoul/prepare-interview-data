{
  "questions": [
    {
      "question": "하드 디스크 드라이브(hard disk drive)에서 데이터를 저장하는 원형 금속판을 ___라 한다.",
      "choices": [
        "자기 디스크(magnetic disk)",
        "플래터(platter)",
        "섹터(sector)",
        "실린더(cylinder)"
      ],
      "answer": 2,
      "explanation": "HDD(Hard Disk Drive)는 데이터를 저장하는 1개 이상의 플래터(platter)를 가지고 있습니다. 플래터는 논리적으로 수많은 트랙(track)으로 나뉘어지고, 트랙은 다시 여러 개의 섹터(sector)로 나뉘어 집니다. 섹터는 디스크에서 제일 작은 단위의 물리적 저장소로, 크기는 512 바이트와 같이 항상 2의 배수입니다. 실린더(cylinder)는 헤드에 위치한 트랙들의 집합으로 플래터가 복수일 때 여러 플래터에 걸친 트랙들이라고도 볼 수 있습니다. 즉, 수직적으로 엮인 집합으로 볼 수 있습니다.",
      "references": [
        {"[한] HDD": "https://ko.wikipedia.org/wiki/%ED%95%98%EB%93%9C_%EB%94%94%EC%8A%A4%ED%81%AC_%EB%93%9C%EB%9D%BC%EC%9D%B4%EB%B8%8C"},
        {"HDD": "https://en.wikipedia.org/wiki/Hard_disk_drive"},
        {"[한] Platter": "https://ko.wikipedia.org/wiki/%ED%95%98%EB%93%9C_%EB%94%94%EC%8A%A4%ED%81%AC_%ED%94%8C%EB%9E%98%ED%84%B0"},
        {"Platter": "https://en.wikipedia.org/wiki/Hard_disk_drive_platter"}
      ]
    },
    {
      "question": "HDD(Hard Disk Drive)에서 한 플래터(platter) 당 ___ 개의 암(arm)이 있고, 각 암에는 ___ 개의 헤드(head)가 있다.",
      "choices": [
        "1, 1",
        "1, 2",
        "2, 1",
        "2, 2"
      ],
      "answer": 3,
      "explanation": "플래터(platter)는 앞면과 뒷면을 모두 사용하기 때문에 한 플래터 당 두 개의 암(arm)이 필요합니다. 각 암에서는 한 개의 헤드로 데이터 읽기 및 쓰기를 모두 합니다. 예를 들어, 4개의 플래터가 있다면 암은 8개 존재합니다.",
      "references": [
        {"[한] HDD": "https://ko.wikipedia.org/wiki/%ED%95%98%EB%93%9C_%EB%94%94%EC%8A%A4%ED%81%AC_%EB%93%9C%EB%9D%BC%EC%9D%B4%EB%B8%8C"},
        {"HDD": "https://en.wikipedia.org/wiki/Hard_disk_drive"}
      ]
    },
    {
      "question": "플래터(platter)가 두개 있는 HDD에서 첫번째 플래터의 10번 섹터와 두번째 플래터의 10번 섹터는 같은 ___에 속한다.",
      "choices": [
        "실린더(cylinder)",
        "트랙(track)",
        "섹터(sector)",
        "액추에이터(actuator)"
      ],
      "answer": 1,
      "explanation": "수직적으로 동일한 위치에 있는 트랙(track) 또는 섹터(sector)들은 같은 실린더(cylinder)에 속합니다. 트랙은 같은 플래터(platter) 상에 있는 섹터들의 집합으로 여러 플래터에 걸쳐 있을 수 없습니다. 섹터는 그 자체로 가장 작은 단위이므로 섹터에 속한다는 것은 말이 되지 않습니다.",
      "references": [
        {"Cylinder": "https://en.wikipedia.org/wiki/Cylinder-head-sector#Cylinders"},
        {"[한] HDD": "https://ko.wikipedia.org/wiki/%ED%95%98%EB%93%9C_%EB%94%94%EC%8A%A4%ED%81%AC_%EB%93%9C%EB%9D%BC%EC%9D%B4%EB%B8%8C"},
        {"HDD": "https://en.wikipedia.org/wiki/Hard_disk_drive"}
      ]
    },
    {
      "question": "HDD의 헤드를 원하는 데이터가 있는 트랙으로 위치시키는데 드는 시간을 ___라 한다.",
      "choices": [
        "탐색 시간(seek time)",
        "회전 지연(rotational latency)",
        "임의 접근 시간(random access time)",
        "디스크 접근 시간(disk access time)"
      ],
      "answer": 1,
      "explanation": "기계 구조상 HDD에서 데이터 접근 시간을 결정짓는 요소는 디스크 회전 및 헤드 이동 시간 등 몇 가지 있습니다. 이 중 탐색 시간(seek time)은 헤드 이동에 대한 부분입니다. 회전 지연(rotational latency 또는 rotational delay)은 원하는 섹터가 헤드 아래에 위치하도록 플래터(platter)를 스핀들 모터(spindle motor)가 회전시키는데 걸리는 시간입니다.",
      "references": [
        {"Seek time": "https://en.wikipedia.org/wiki/Hard_disk_drive_performance_characteristics#Seek_time"},
        {"Rotational latency": "https://en.wikipedia.org/wiki/Hard_disk_drive_performance_characteristics#Rotational_latency"},
        {"[한] HDD": "https://ko.wikipedia.org/wiki/%ED%95%98%EB%93%9C_%EB%94%94%EC%8A%A4%ED%81%AC_%EB%93%9C%EB%9D%BC%EC%9D%B4%EB%B8%8C"},
        {"HDD": "https://en.wikipedia.org/wiki/Hard_disk_drive"}
      ]
    },
    {
      "question": "HDD의 헤드가 플래터의 표면에 충돌하여 영구적 손상을 일으키는 것을 무엇이라 하는가?",
      "choices": [
        "플래터 스크래치(platter scratch)",
        "플래터 크래시(platter crash)",
        "디스크 크래시(disk crash)",
        "헤드 크래시(head crash)"
      ],
      "answer": 4,
      "explanation": "플래터와 헤드는 물리적으로 매우 가깝게 위치하고 있기 때문에, 노트북을 떨어트리는 등 충격이 발생할 경우 쉽게 스크래치가 생길 수 있습니다. 특히, 플래터가 회전 중일 경우 헤드와 플래터가 맞닿는 순간이 일순간이더라도 빠르게 회전하고 있기 때문에 손상이 커집니다. 이 경우 표면에 스크래치가 원형으로 남습니다. 완벽하게 해결할 수는 없지만, 손상되기 쉬운 단점을 완화시키고자 스크래치가 다소 남더라도 읽고 쓰기에는 문제가 없도록 플래터를 두껍게 만들어 보호하는 계층을 두기도 합니다.\n플래터는 스핀들 모터에 의해 10,000 RPM 전후의 속도로 회전하기 때문에 헤드가 충돌하면 고열도 발생합니다. 따라서 손상된 부분이 아니더라도 헤드가 냉각될 때까지는 읽고 쓰기를 못하는 경우가 발생할 수도 있습니다.",
      "references": [
        {"Head crash": "https://en.wikipedia.org/wiki/Head_crash"},
        {"[한] HDD": "https://ko.wikipedia.org/wiki/%ED%95%98%EB%93%9C_%EB%94%94%EC%8A%A4%ED%81%AC_%EB%93%9C%EB%9D%BC%EC%9D%B4%EB%B8%8C"},
        {"HDD": "https://en.wikipedia.org/wiki/Hard_disk_drive"}
      ]
    },
    {
      "question": "HDD 대역폭(bandwidth)에 대한 설명으로 틀린 것은?",
      "choices": [
        "대역폭이 높을 수록 전송 속도가 빠른 것을 의미한다.",
        "같은 크기의 데이터에 대해서, 일반적으로 큰 블록 하나를 읽는 것이 작은 블록을 여러번 읽는 것보다 대역폭이 낮다.",
        "일반적으로 읽기가 쓰기보다 높다.",
        "일반적으로 SSD(Solid State Drive)보다 낮다."
      ],
      "answer": 2,
      "explanation": "HDD에서 여러 블록을 읽어야 하는 경우, 보통 헤드를 이동시키거나 플래터를 회전시켜야 해서 데이터에 접근하는데 시간이 더 걸립니다. 만약 플래터가 여러개 있는 HDD에서 읽어야 할 블록들이 헤드의 이동이 필요없도록 같은 실린더의 여러 플래터에 걸쳐 위치하고 있다면, 여러 헤드에서 동시에 읽는 것이 가능하여 읽기를 더 빨리 완료할 수도 있습니다. 하지만 이는 흔치않은 경우입니다.",
      "references": [
        {"HDD performance": "https://en.wikipedia.org/wiki/Hard_disk_drive_performance_characteristics"},
        {"[한] HDD": "https://ko.wikipedia.org/wiki/%ED%95%98%EB%93%9C_%EB%94%94%EC%8A%A4%ED%81%AC_%EB%93%9C%EB%9D%BC%EC%9D%B4%EB%B8%8C"},
        {"HDD": "https://en.wikipedia.org/wiki/Hard_disk_drive"}
      ]
    },
    {
      "question": "SSD(Solid State Drive)에 대한 설명으로 틀린 것은?",
      "choices": [
        "휘발성 메모리를 기반으로 하기도 한다.",
        "같은 용량이라면 HDD보다 비싸다.",
        "HDD보다 충격에 강하다.",
        "HDD보다 무조건 빠르다."
      ],
      "answer": 4,
      "explanation": "SSD(Solid State Drive)는 플래시 메모리(flash memory) 또는 RAM(Random Access Memory)를 기반으로 하는 저장장치입니다. 기반에 따라 각기 다른 특성을 가집니다. 플래시 메모리가 기반일 경우, 비휘발성 매체에 쓰다보니 백업 시스템이 필요없어 전력이 불안정한 상황에서도 데이터 손실이 발생할 가능성이 비교적 낮습니다. RAM 기반은 휘발성 메모리를 쓰다보니 백업 스토리지 시스템(backup storage system)이 필요하지만, 접근 속도(access time)가 매우 빨라 비용보다 성능을 내는 것이 중요한 서버에 쓰이고는 합니다.\nSSD는 전자식이므로 기계식인 HDD가 가지고 있던 물리적 한계를 많이 극복하여 보통 HDD보다 빠릅니다. 하지만 초기에는 연속된 사용에 HDD보다 느린 모습을 보여주기도 했습니다. 또한 SSD는 읽기만 하거나 쓰기만 하는 것보다 읽기와 쓰기를 번갈아가며 할 때 성능이 저하되기도 하고, 사용 기간이 길어질 수록 오류가 증가하는 영향 등으로 성능이 저하되기도 하기 때문에 초기의 SSD가 아니더라도 HDD보다 느려질 수도 있어 항상 빠르다고 말하는 것은 틀릴 수 있습니다.",
      "references": [
        {"[한] SSD": "https://ko.wikipedia.org/wiki/%EC%86%94%EB%A6%AC%EB%93%9C_%EC%8A%A4%ED%85%8C%EC%9D%B4%ED%8A%B8_%EB%93%9C%EB%9D%BC%EC%9D%B4%EB%B8%8C"},
        {"SSD": "https://en.wikipedia.org/wiki/Solid-state_drive"},
        {"[한] Flash memory": "https://ko.wikipedia.org/wiki/%ED%94%8C%EB%9E%98%EC%8B%9C_%EB%A9%94%EB%AA%A8%EB%A6%AC"},
        {"Flash memory": "https://en.wikipedia.org/wiki/Flash_memory"},
        {"[한] HDD": "https://ko.wikipedia.org/wiki/%ED%95%98%EB%93%9C_%EB%94%94%EC%8A%A4%ED%81%AC_%EB%93%9C%EB%9D%BC%EC%9D%B4%EB%B8%8C"},
        {"HDD": "https://en.wikipedia.org/wiki/Hard_disk_drive"}
      ]
    },
    {
      "question": "헤드의 현재 위치가 53이고 I/O 요청 큐에 98, 183, 37, 122, 14, 124, 65, 67가 들어있다면, 요청을 완수하기 위해 FCFS 스케줄링으로는 헤드를 얼마나 이동시켜야 하는가?",
      "choices": [
        "236",
        "240",
        "640",
        "660"
      ],
      "answer": 3,
      "explanation": "FCFS(First Come First Served)는 처음 온 요청부터 처리하는 방식으로 큐에 있는 순서대로 처리하게 됩니다. 따라서 헤드는 53, 98, 183, 37, 122, 14, 124, 65, 67 순으로 이동하고 이동한 거리는 요청 위치 간의 거리들을 합하면 됩니다. (98 - 53) + (183 - 98) + (183 - 37) + (122 - 37) + (122 - 14) + (124 - 14) + (124 - 65) + (67 - 65) = 640",
      "references": [
        {"[한] FCFS": "https://ko.wikipedia.org/wiki/%EC%84%A0%EC%9E%85_%EC%84%A0%EC%B2%98%EB%A6%AC"},
        {"FCFS": "https://en.wikipedia.org/wiki/FIFO_(computing_and_electronics)"},
        {"[한] Disk Scheduling": "https://ko.wikipedia.org/wiki/%EC%9E%85%EC%B6%9C%EB%A0%A5_%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81"},
        {"Disk Scheduling": "https://en.wikipedia.org/wiki/I/O_scheduling"}
      ]
    },
    {
      "question": "헤드의 현재 위치가 53이고 I/O 요청 큐에 98, 183, 37, 122, 14, 124, 65, 67가 들어있다면, 요청을 완수하기 위해 SSTF 스케줄링으로는 헤드를 얼마나 이동시켜야 하는가?",
      "choices": [
        "236",
        "240",
        "640",
        "660"
      ],
      "answer": 1,
      "explanation": "SSTF(Shortest Seek Time First)는 현재 헤드의 위치에서 탐색 시간이 제일 짧은 순으로 스케줄링하는 방식입니다. 따라서 헤드는 53, 65, 67, 37, 14, 98, 122, 124, 183 순으로 이동한 거리는 요청 위치 간의 거리들을 합하면 됩니다. (65 - 53) + (67 - 65) + (67 - 37) + (37 - 14) + (98 - 14) + (122 - 98) + (124 - 122) + (183 - 124) = 236",
      "references": [
        {"SSTF": "https://en.wikipedia.org/wiki/Shortest_seek_first"},
        {"[한] Disk Scheduling": "https://ko.wikipedia.org/wiki/%EC%9E%85%EC%B6%9C%EB%A0%A5_%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81"},
        {"Disk Scheduling": "https://en.wikipedia.org/wiki/I/O_scheduling"}
      ]
    },
    {
      "question": "헤드의 현재 위치가 53이고 I/O 요청 큐에 98, 183, 37, 122, 14, 124, 65, 67가 들어있다면, 요청을 완수하기 위해 SCAN 스케줄링으로는 헤드를 얼마나 이동시켜야 하는가? 헤드의 이동 가능 범위는 0 ~ 199라 가정한다.",
      "choices": [
        "236",
        "240",
        "640",
        "660"
      ],
      "answer": 1,
      "explanation": "SCAN은 정해진 방향으로 끝까지 이동한 뒤 끝에 도달하면 반대 방향으로 탐색을 진행하는 방식으로 엘리베이터 알고리즘(elevator algorithm)이라고도 불립니다. 따라서 0 쪽으로 먼저 이동한다면 53, 37, 14, 0, 65, 67, 98, 122, 124, 183 순으로 접근하게 되고 199 쪽으로 먼저 이동한다면 53, 65, 67, 98, 122, 124, 183, 199, 37, 14 순으로 접근하게 됩니다. 따라서 236 또는 331이 답이 된다.",
      "references": [
        {"SSTF": "https://en.wikipedia.org/wiki/Shortest_seek_first"},
        {"[한] Disk Scheduling": "https://ko.wikipedia.org/wiki/%EC%9E%85%EC%B6%9C%EB%A0%A5_%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81"},
        {"Disk Scheduling": "https://en.wikipedia.org/wiki/I/O_scheduling"}
      ]
    },
    {
      "question": "헤드의 현재 위치가 53이고 I/O 요청 큐에 98, 183, 37, 122, 14, 124, 65, 67가 들어있다면, 요청을 완수하기 위해 C-SCAN 스케줄링으로는 헤드를 얼마나 이동시켜야 하는가? 헤드의 이동 가능 범위는 0 ~ 199라 가정한다.",
      "choices": [
        "236",
        "240",
        "382",
        "400"
      ],
      "answer": 1,
      "explanation": "C-SCAN(Circular-SCAN)은 실린더(cylinder)를 순환 배열로 보는 방식으로, 한 방향에서만 읽기 및 쓰기를 실행합니다. 헤드가 끝에 도착하면 첫 위치로 이동한 뒤에 탐색을 재개합니다. 따라서 53부터 시작하여 199까지 이동하였다가 0으로 되돌아간 뒤, 14와 37에 접근합니다.",
      "references": [
        {"SSTF": "https://en.wikipedia.org/wiki/Shortest_seek_first"},
        {"[한] Disk Scheduling": "https://ko.wikipedia.org/wiki/%EC%9E%85%EC%B6%9C%EB%A0%A5_%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81"},
        {"Disk Scheduling": "https://en.wikipedia.org/wiki/I/O_scheduling"}
      ]
    }
  ]
}
