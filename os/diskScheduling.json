{
  "questions": [
    {
      "question": "하드 디스크 드라이브(hard disk drive)에서 데이터를 저장하는 원형 금속판을 ___라 한다.",
      "choices": [
        "자기 디스크(magnetic disk)",
        "플래터(platter)",
        "섹터(sector)",
        "실린더(cylinder)"
      ],
      "answer": 2,
      "explanation": "HDD(Hard Disk Drive)는 데이터를 저장하는 1개 이상의 플래터(platter)를 가지고 있습니다. 플래터는 논리적으로 수많은 트랙(track)으로 나뉘어지고, 트랙은 다시 여러 개의 섹터(sector)로 나뉘어 집니다. 섹터는 디스크에서 제일 작은 단위의 물리적 저장소로, 크기는 512 바이트와 같이 항상 2의 배수입니다. 실린더(cylinder)는 헤드에 위치한 트랙들의 집합으로 플래터가 복수일 때 여러 플래터에 걸친 트랙들이라고도 볼 수 있습니다. 즉, 수직적으로 엮인 집합으로 볼 수 있습니다.",
      "references": [
        {"[한] HDD": "https://ko.wikipedia.org/wiki/%ED%95%98%EB%93%9C_%EB%94%94%EC%8A%A4%ED%81%AC_%EB%93%9C%EB%9D%BC%EC%9D%B4%EB%B8%8C"},
        {"HDD": "https://en.wikipedia.org/wiki/Hard_disk_drive"},
        {"[한] Platter": "https://ko.wikipedia.org/wiki/%ED%95%98%EB%93%9C_%EB%94%94%EC%8A%A4%ED%81%AC_%ED%94%8C%EB%9E%98%ED%84%B0"},
        {"Platter": "https://en.wikipedia.org/wiki/Hard_disk_drive_platter"}
      ]
    },
    {
      "question": "HDD(Hard Disk Drive)에서 한 플래터(platter) 당 ___ 개의 암(arm)이 있고, 각 암에는 ___ 개의 헤드(head)가 있다.",
      "choices": [
        "1, 1",
        "1, 2",
        "2, 1",
        "2, 2"
      ],
      "answer": 3,
      "explanation": "플래터(platter)는 앞면과 뒷면을 모두 사용하기 때문에 한 플래터 당 두 개의 암(arm)이 필요합니다. 각 암에서는 한 개의 헤드로 데이터 읽기 및 쓰기를 모두 합니다. 예를 들어, 4개의 플래터가 있다면 암은 8개 존재합니다.",
      "references": [
        {"[한] HDD": "https://ko.wikipedia.org/wiki/%ED%95%98%EB%93%9C_%EB%94%94%EC%8A%A4%ED%81%AC_%EB%93%9C%EB%9D%BC%EC%9D%B4%EB%B8%8C"},
        {"HDD": "https://en.wikipedia.org/wiki/Hard_disk_drive"}
      ]
    },
    {
      "question": "플래터(platter)가 두개 있는 HDD에서 첫번째 플래터의 10번 섹터와 두번째 플래터의 10번 섹터는 같은 ___에 속한다.",
      "choices": [
        "실린더(cylinder)",
        "트랙(track)",
        "섹터(sector)",
        "액추에이터(actuator)"
      ],
      "answer": 1,
      "explanation": "수직적으로 동일한 위치에 있는 트랙(track) 또는 섹터(sector)들은 같은 실린더(cylinder)에 속합니다. 트랙은 같은 플래터(platter) 상에 있는 섹터들의 집합으로 여러 플래터에 걸쳐 있을 수 없습니다. 섹터는 그 자체로 가장 작은 단위이므로 섹터에 속한다는 것은 말이 되지 않습니다.",
      "references": [
        {"Cylinder": "https://en.wikipedia.org/wiki/Cylinder-head-sector#Cylinders"},
        {"[한] HDD": "https://ko.wikipedia.org/wiki/%ED%95%98%EB%93%9C_%EB%94%94%EC%8A%A4%ED%81%AC_%EB%93%9C%EB%9D%BC%EC%9D%B4%EB%B8%8C"},
        {"HDD": "https://en.wikipedia.org/wiki/Hard_disk_drive"}
      ]
    },
    {
      "question": "HDD의 헤드를 원하는 데이터가 있는 트랙으로 위치시키는데 드는 시간을 ___라 한다.",
      "choices": [
        "탐색 시간(seek time)",
        "회전 지연(rotational latency)",
        "임의 접근 시간(random access time)",
        "디스크 접근 시간(disk access time)"
      ],
      "answer": 1,
      "explanation": "기계 구조상 HDD에서 데이터 접근 시간을 결정짓는 요소는 디스크 회전 및 헤드 이동 시간 등 몇 가지 있습니다. 이 중 탐색 시간(seek time)은 헤드 이동에 대한 부분입니다. 회전 지연(rotational latency 또는 rotational delay)은 원하는 섹터가 헤드 아래에 위치하도록 플래터(platter)를 스핀들 모터(spindle motor)가 회전시키는데 걸리는 시간입니다.",
      "references": [
        {"Seek time": "https://en.wikipedia.org/wiki/Hard_disk_drive_performance_characteristics#Seek_time"},
        {"Rotational latency": "https://en.wikipedia.org/wiki/Hard_disk_drive_performance_characteristics#Rotational_latency"},
        {"[한] HDD": "https://ko.wikipedia.org/wiki/%ED%95%98%EB%93%9C_%EB%94%94%EC%8A%A4%ED%81%AC_%EB%93%9C%EB%9D%BC%EC%9D%B4%EB%B8%8C"},
        {"HDD": "https://en.wikipedia.org/wiki/Hard_disk_drive"}
      ]
    },
    {
      "question": "HDD의 헤드가 플래터의 표면에 충돌하여 영구적 손상을 일으키는 것을 무엇이라 하는가?",
      "choices": [
        "플래터 스크래치(platter scratch)",
        "플래터 크래시(platter crash)",
        "디스크 크래시(disk crash)",
        "헤드 크래시(head crash)"
      ],
      "answer": 4,
      "explanation": "플래터와 헤드는 물리적으로 매우 가깝게 위치하고 있기 때문에, 노트북을 떨어트리는 등 충격이 발생할 경우 쉽게 스크래치가 생길 수 있습니다. 특히, 플래터가 회전 중일 경우 헤드와 플래터가 맞닿는 순간이 일순간이더라도 빠르게 회전하고 있기 때문에 손상이 커집니다. 이 경우 표면에 스크래치가 원형으로 남습니다. 완벽하게 해결할 수는 없지만, 손상되기 쉬운 단점을 완화시키고자 스크래치가 다소 남더라도 읽고 쓰기에는 문제가 없도록 플래터를 두껍게 만들어 보호하는 계층을 두기도 합니다.\n플래터는 스핀들 모터에 의해 10,000 RPM 전후의 속도로 회전하기 때문에 헤드가 충돌하면 고열도 발생합니다. 따라서 손상된 부분이 아니더라도 헤드가 냉각될 때까지는 읽고 쓰기를 못하는 경우가 발생할 수도 있습니다.",
      "references": [
        {"Head crash": "https://en.wikipedia.org/wiki/Head_crash"},
        {"[한] HDD": "https://ko.wikipedia.org/wiki/%ED%95%98%EB%93%9C_%EB%94%94%EC%8A%A4%ED%81%AC_%EB%93%9C%EB%9D%BC%EC%9D%B4%EB%B8%8C"},
        {"HDD": "https://en.wikipedia.org/wiki/Hard_disk_drive"}
      ]
    },
    {
      "question": "HDD 대역폭(bandwidth)에 대한 설명으로 틀린 것은?",
      "choices": [
        "대역폭이 높을 수록 전송 속도가 빠른 것을 의미한다.",
        "같은 크기의 데이터에 대해서, 일반적으로 큰 블록 하나를 읽는 것이 작은 블록을 여러번 읽는 것보다 대역폭이 낮다.",
        "일반적으로 읽기가 쓰기보다 높다.",
        "일반적으로 SSD(Solid State Drive)보다 낮다."
      ],
      "answer": 2,
      "explanation": "HDD에서 여러 블록을 읽어야 하는 경우, 보통 헤드를 이동시키거나 플래터를 회전시켜야 해서 데이터에 접근하는데 시간이 더 걸립니다. 만약 플래터가 여러개 있는 HDD에서 읽어야 할 블록들이 헤드의 이동이 필요없도록 같은 실린더의 여러 플래터에 걸쳐 위치하고 있다면, 여러 헤드에서 동시에 읽는 것이 가능하여 읽기를 더 빨리 완료할 수도 있습니다. 하지만 이는 흔치않은 경우입니다.",
      "references": [
        {"HDD performance": "https://en.wikipedia.org/wiki/Hard_disk_drive_performance_characteristics"},
        {"[한] HDD": "https://ko.wikipedia.org/wiki/%ED%95%98%EB%93%9C_%EB%94%94%EC%8A%A4%ED%81%AC_%EB%93%9C%EB%9D%BC%EC%9D%B4%EB%B8%8C"},
        {"HDD": "https://en.wikipedia.org/wiki/Hard_disk_drive"}
      ]
    },
    {
      "question": "SSD(Solid State Drive)에 대한 설명으로 틀린 것은?",
      "choices": [
        "휘발성 메모리를 기반으로 하기도 한다.",
        "같은 용량이라면 HDD보다 비싸다.",
        "HDD보다 충격에 강하다.",
        "HDD보다 무조건 빠르다."
      ],
      "answer": 4,
      "explanation": "SSD(Solid State Drive)는 플래시 메모리(flash memory) 또는 RAM(Random Access Memory)를 기반으로 하는 저장장치입니다. 기반에 따라 각기 다른 특성을 가집니다. 플래시 메모리가 기반일 경우, 비휘발성 매체에 쓰다보니 백업 시스템이 필요없어 전력이 불안정한 상황에서도 데이터 손실이 발생할 가능성이 비교적 낮습니다. RAM 기반은 휘발성 메모리를 쓰다보니 백업 스토리지 시스템(backup storage system)이 필요하지만, 접근 속도(access time)가 매우 빨라 비용보다 성능을 내는 것이 중요한 서버에 쓰이고는 합니다.\nSSD는 전자식이므로 기계식인 HDD가 가지고 있던 물리적 한계를 많이 극복하여 보통 HDD보다 빠릅니다. 하지만 초기에는 연속된 사용에 HDD보다 느린 모습을 보여주기도 했습니다. 또한 SSD는 읽기만 하거나 쓰기만 하는 것보다 읽기와 쓰기를 번갈아가며 할 때 성능이 저하되기도 하고, 사용 기간이 길어질 수록 오류가 증가하는 영향 등으로 성능이 저하되기도 하기 때문에 초기의 SSD가 아니더라도 HDD보다 느려질 수도 있어 항상 빠르다고 말하는 것은 틀릴 수 있습니다.",
      "references": [
        {"[한] SSD": "https://ko.wikipedia.org/wiki/%EC%86%94%EB%A6%AC%EB%93%9C_%EC%8A%A4%ED%85%8C%EC%9D%B4%ED%8A%B8_%EB%93%9C%EB%9D%BC%EC%9D%B4%EB%B8%8C"},
        {"SSD": "https://en.wikipedia.org/wiki/Solid-state_drive"},
        {"[한] Flash memory": "https://ko.wikipedia.org/wiki/%ED%94%8C%EB%9E%98%EC%8B%9C_%EB%A9%94%EB%AA%A8%EB%A6%AC"},
        {"Flash memory": "https://en.wikipedia.org/wiki/Flash_memory"},
        {"[한] HDD": "https://ko.wikipedia.org/wiki/%ED%95%98%EB%93%9C_%EB%94%94%EC%8A%A4%ED%81%AC_%EB%93%9C%EB%9D%BC%EC%9D%B4%EB%B8%8C"},
        {"HDD": "https://en.wikipedia.org/wiki/Hard_disk_drive"}
      ]
    },
    {
      "question": "헤드의 현재 위치가 실린더 53이고 I/O 요청 큐에 98, 183, 37, 122, 14, 124, 65, 67가 들어있다면, 요청을 완수하기 위해 FCFS 스케줄링으로는 헤드를 얼마나 이동시켜야 하는가?",
      "choices": [
        "236",
        "240",
        "640",
        "660"
      ],
      "answer": 3,
      "explanation": "FCFS(First Come First Served)는 처음 온 요청부터 처리하는 방식으로 큐에 있는 순서대로 처리하게 됩니다. 따라서 헤드는 실린더 53, 98, 183, 37, 122, 14, 124, 65, 67 순으로 이동하고 이동한 거리는 요청 위치 간의 거리들을 합하면 됩니다.\n\n(98 - 53) + (183 - 98) + (183 - 37) + (122 - 37) + (122 - 14) + (124 - 14) + (124 - 65) + (67 - 65)\n= 640",
      "references": [
        {"[한] FCFS": "https://ko.wikipedia.org/wiki/%EC%84%A0%EC%9E%85_%EC%84%A0%EC%B2%98%EB%A6%AC"},
        {"FCFS": "https://en.wikipedia.org/wiki/FIFO_(computing_and_electronics)"},
        {"[한] Disk Scheduling": "https://ko.wikipedia.org/wiki/%EC%9E%85%EC%B6%9C%EB%A0%A5_%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81"},
        {"Disk Scheduling": "https://en.wikipedia.org/wiki/I/O_scheduling"}
      ]
    },
    {
      "question": "헤드의 현재 위치가 실린더 53이고 I/O 요청 큐에 98, 183, 37, 122, 14, 124, 65, 67가 들어있다면, 요청을 완수하기 위해 SSTF 스케줄링으로는 헤드를 얼마나 이동시켜야 하는가?",
      "choices": [
        "236",
        "240",
        "640",
        "660"
      ],
      "answer": 1,
      "explanation": "SSTF(Shortest Seek Time First)는 현재 헤드의 위치에서 탐색 시간이 제일 짧은 순으로 스케줄링하는 방식입니다. 따라서 헤드는 실린더 53, 65, 67, 37, 14, 98, 122, 124, 183 순으로 이동한 거리는 요청 위치 간의 거리들을 합하면 됩니다.\n\n(65 - 53) + (67 - 65) + (67 - 37) + (37 - 14) + (98 - 14) + (122 - 98) + (124 - 122) + (183 - 124)\n= (67 - 53) + (67 - 14) + (183 - 14)\n= 236",
      "references": [
        {"SSTF": "https://en.wikipedia.org/wiki/Shortest_seek_first"},
        {"[한] Disk Scheduling": "https://ko.wikipedia.org/wiki/%EC%9E%85%EC%B6%9C%EB%A0%A5_%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81"},
        {"Disk Scheduling": "https://en.wikipedia.org/wiki/I/O_scheduling"}
      ]
    },
    {
      "question": "헤드의 현재 위치가 실린더 53이고 I/O 요청 큐에 98, 183, 37, 122, 14, 124, 65, 67가 들어있다면, 요청을 완수하기 위해 SCAN 스케줄링으로는 헤드를 얼마나 이동시켜야 하는가? 디스크는 200개의 실린더(0 ~ 199)를 가진다고 가정한다.",
      "choices": [
        "236",
        "240",
        "640",
        "660"
      ],
      "answer": 1,
      "explanation": "SCAN은 정해진 방향으로 끝까지 이동한 뒤 끝에 도달하면 반대 방향으로 탐색을 진행하는 방식으로 엘리베이터 알고리즘(elevator algorithm)이라고도 불립니다. 따라서 실린더 0 쪽으로 먼저 이동한다면 53, 37, 14, 0, 65, 67, 98, 122, 124, 183 순으로 접근하게 되고 실린더 199 쪽으로 먼저 이동한다면 53, 65, 67, 98, 122, 124, 183, 199, 37, 14 순으로 접근하게 됩니다. 따라서 236 또는 331이 답이 됩니다.",
      "references": [
        {"SCAN": "https://en.wikipedia.org/wiki/Elevator_algorithm"},
        {"[한] Disk Scheduling": "https://ko.wikipedia.org/wiki/%EC%9E%85%EC%B6%9C%EB%A0%A5_%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81"},
        {"Disk Scheduling": "https://en.wikipedia.org/wiki/I/O_scheduling"}
      ]
    },
    {
      "question": "헤드의 현재 위치가 실린더 53이고 I/O 요청 큐에 98, 183, 37, 122, 14, 124, 65, 67가 들어있다면, 요청을 완수하기 위해 C-SCAN 스케줄링으로는 헤드를 얼마나 이동시켜야 하는가? 디스크는 200개의 실린더(0 ~ 199)를 가진다고 가정한다.",
      "choices": [
        "236",
        "240",
        "382",
        "400"
      ],
      "answer": 3,
      "explanation": "C-SCAN(Circular-SCAN)은 실린더(cylinder)를 순환 배열로 보는 방식으로, 한 이동 방향에서만 읽기 및 쓰기를 실행합니다. 헤드가 디스크의 끝에 도착하면 첫 위치로 이동한 뒤에 탐색을 재개합니다. 따라서 실린더 53에서 시작하여 실린더 199까지 이동하였다가 실린더 0으로 되돌아간 뒤, 14와 37에 접근합니다.\n\n(199 - 53) + (199 - 0) + (37 - 0)\n= 382",
      "references": [
        {"SCAN": "https://en.wikipedia.org/wiki/Elevator_algorithm"},
        {"[한] Disk Scheduling": "https://ko.wikipedia.org/wiki/%EC%9E%85%EC%B6%9C%EB%A0%A5_%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81"},
        {"Disk Scheduling": "https://en.wikipedia.org/wiki/I/O_scheduling"}
      ]
    },
    {
      "question": "헤드의 현재 위치가 실린더 53이고 I/O 요청 큐에 98, 183, 37, 122, 14, 124, 65, 67가 들어있다면, 요청을 완수하기 위해 LOOK 스케줄링으로는 헤드를 얼마나 이동시켜야 하는가? 디스크는 200개의 실린더(0 ~ 199)를 가진다고 가정한다.",
      "choices": [
        "382",
        "322",
        "300",
        "299"
      ],
      "answer": 4,
      "explanation": "LOOK 알고리즘은 SCAN 알고리즘과 비슷하게 끝까지 헤드를 이동시킨 뒤 반전시키는 방식입니다. 다만 SCAN과 다르게 LOOK 알고리즘은 디스크의 끝이 아니라, 요청의 끝까지라서 SCAN에 비해 먼저 반대 방향으로 탐색을 시작해 더 효율적일 수 있습니다. 예를 들어, 문제와 같이 실린더가 200개일 때 헤드의 현재 위치가 실린더 100이고 요청이 실린더 150에 있다면, SCAN은 실린더 199까지 이동한 다음에야 실린더 0 방향으로 움직이기 시작하는 반면 LOOK은 실린더 150까지만 이동하여 읽은 후 실린더 0 방향으로 움직이기 시작합니다.\n따라서 문제의 경우, 실린더 199 방향으로 먼저 움직였다면 실린더 53에서 실린더 183까지만 이동한 뒤에 실린더 37, 14 순으로 접근합니다. 만약 실린더 0 방향으로 먼저 움직였다면 실린더 53에서 실린더 14까지만 이동한 뒤 실린더 183까지 이동합니다. 따라서 299 또는 208이 답입니다.\n\n(183 - 53) + (183 - 37) + (37 - 14)\n= (183 - 53) + (183 - 14)\n= 299\n\n(53 - 14) + (183 - 14)\n= 208",
      "references": [
        {"LOOK": "https://en.wikipedia.org/wiki/LOOK_algorithm"},
        {"SCAN": "https://en.wikipedia.org/wiki/Elevator_algorithm"},
        {"[한] Disk Scheduling": "https://ko.wikipedia.org/wiki/%EC%9E%85%EC%B6%9C%EB%A0%A5_%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81"},
        {"Disk Scheduling": "https://en.wikipedia.org/wiki/I/O_scheduling"}
      ]
    },
    {
      "question": "헤드의 현재 위치가 실린더 53이고 I/O 요청 큐에 98, 183, 37, 122, 14, 124, 65, 67가 들어있다면, 요청을 완수하기 위해 C-LOOK 스케줄링으로는 헤드를 얼마나 이동시켜야 하는가? 디스크는 200개의 실린더(0 ~ 199)를 가진다고 가정한다.",
      "choices": [
        "382",
        "322",
        "300",
        "299"
      ],
      "answer": 2,
      "explanation": "C-LOOK 알고리즘은 기본적으로 LOOK 알고리즘과 거의 유사하지만 C-SCAN처럼 실린더(cylinder)를 순환 배열로 보는 방식입니다. 즉, 한 이동 방향에서만 읽고 쓰기를 하는데, 디스크의 끝이 아니라 요청이 더 이상 없을 때까지 이동합니다. 따라서 문제의 경우 실린더 53에서 시작하여 실린더 183까지 이동하였다가, 실린더 0이 아닌 실린더 14로 되돌아간 뒤 다시 읽기 시작해 실린더 37에서 읽기를 마칩니다.\n\n(183 - 53) + (183 - 14) + (37 - 14)\n= 322",
      "references": [
        {"LOOK": "https://en.wikipedia.org/wiki/LOOK_algorithm"},
        {"SCAN": "https://en.wikipedia.org/wiki/Elevator_algorithm"},
        {"[한] Disk Scheduling": "https://ko.wikipedia.org/wiki/%EC%9E%85%EC%B6%9C%EB%A0%A5_%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81"},
        {"Disk Scheduling": "https://en.wikipedia.org/wiki/I/O_scheduling"}
      ]
    },
    {
      "question": "SSTF 알고리즘은 ___ 문제를 야기할 수 있다.",
      "choices": [
        "교착 상태(deadlock)",
        "기아(starvation)",
        "에이징(aging)",
        "고아(orphan)"
      ],
      "answer": 2,
      "explanation": "SSTF(Shortest Seek Time First) 알고리즘은 헤드의 현재 위치에 가까운 요청부터 처리하므로, 나중에 들어온 요청이더라도 먼저 처리할 수 있습니다. 가까운 곳의 요청이 계속해서 반복될 경우, 현재 헤드에서 먼 곳에 위치한 요청은 언제 처리가 끝날지 보장받을 수 없는 문제가 발생합니다. 계속해서 CPU를 할당받지 못할 경우 발생하는 프로세스의 기아(starvation) 상태와 유사합니다.",
      "references": [
        {"SSTF": "https://en.wikipedia.org/wiki/Shortest_seek_first"},
        {"[한] Disk Scheduling": "https://ko.wikipedia.org/wiki/%EC%9E%85%EC%B6%9C%EB%A0%A5_%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81"},
        {"Disk Scheduling": "https://en.wikipedia.org/wiki/I/O_scheduling"}
      ]
    },
    {
      "question": "___ 알고리즘은 헤드를 디스크의 끝까지 이동시키며 I/O 요청을 처리한 뒤, 디스크의 처음으로 돌아가 다시 처리하기 시작한다.",
      "choices": [
        "SCAN",
        "C-SCAN",
        "LOOK",
        "C-LOOK"
      ],
      "answer": 2,
      "explanation": "SCAN은 헤드를 디스크의 끝에서 끝까지 반복하여 이동시키며 I/O 요청을 처리하는 방식입니다. SCAN의 변형 중 C-SCAN은 한 방향으로 이동할 때만 요청을 처리합니다. 끝에 도달하였을 때 처음으로 되돌아가는 시간이 걸리기에 낭비라고 보일 수 있으나, SCAN보다 요청들을 균등하게 처리하게 만들어 줍니다.",
      "references": [
        {"SCAN": "https://en.wikipedia.org/wiki/Elevator_algorithm"},
        {"LOOK": "https://en.wikipedia.org/wiki/LOOK_algorithm"},
        {"[한] Disk Scheduling": "https://ko.wikipedia.org/wiki/%EC%9E%85%EC%B6%9C%EB%A0%A5_%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81"},
        {"Disk Scheduling": "https://en.wikipedia.org/wiki/I/O_scheduling"}
      ]
    },
    {
      "question": "___ 알고리즘은 I/O 요청 중 헤드에서 제일 멀리 떨어진 요청까지 처리한 뒤, 반대 방향으로 이동하며 경로에 위치한 요청들을 처리한다.",
      "choices": [
        "SCAN",
        "C-SCAN",
        "LOOK",
        "C-LOOK"
      ],
      "answer": 3,
      "explanation": "LOOK은 SCAN과 달리, 무조건 헤드를 디스크의 끝까지 이동시키는 것이 아니라 요청이 있는 위치까지만 갔다가 반대 방향으로 이동시킵니다.",
      "references": [
        {"SCAN": "https://en.wikipedia.org/wiki/Elevator_algorithm"},
        {"LOOK": "https://en.wikipedia.org/wiki/LOOK_algorithm"},
        {"[한] Disk Scheduling": "https://ko.wikipedia.org/wiki/%EC%9E%85%EC%B6%9C%EB%A0%A5_%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81"},
        {"Disk Scheduling": "https://en.wikipedia.org/wiki/I/O_scheduling"}
      ]
    },
    {
      "question": "섹터 슬리핑(sector slipping)이란?",
      "choices": [
        "섹터를 연속해서 할당하는 기법",
        "섹터를 연속해서 읽는 기법",
        "배드 섹터를 복구하는 기법",
        "배드 섹터를 교체하는 기법"
      ],
      "answer": 4,
      "explanation": "섹터 슬리핑(sector slipping)은 배드 섹터(bad sector)가 감지되었을 때, 여분으로 가지고 있던 스페어 섹터(spare sector)로 대치시키는 기법입니다. 기계 장치인 이상 다양한 물리적 결함에 의해 언제든 손상될 수 있어, 이러한 문제를 극복하고자 섹터 슬리핑 외에도 다양한 장애 대응 기법들이 있습니다.",
      "references": [
        {"Sector slipping": "https://en.wikipedia.org/wiki/Sector_slipping"}
      ]
    },
    {
      "question": "다음 중 SSD의 셀(cell)에 대한 설명으로 틀린 것은?",
      "choices": [
        "SLC(Single-Level Cell) 보다 TLC(Triple-Level Cell)가 더 많은 정보를 저장한다.",
        "SLC 보다 MLC(Multi-Level Cell)를 읽고 쓰는 속도가 더 느리다.",
        "같은 저장 용량을 확보하려면 MLC보다 TLC가 더 비싸다.",
        "TLC를 SLC처럼 사용하기도 한다."
      ],
      "answer": 3,
      "explanation": "SLC(Single-Level Cell), MLC(Multi-Level Cell), TLC(Triple-Level Cell)은 각각 한 셀에 1, 2, 3 비트를 저장할 수 있습니다. 한 셀에 저장하는 데이터의 크기가 클수록 읽고 쓰는 속도가 느려지기 때문에 SLC가 제일 빠릅니다. 하지만 MLC 및 TLC와 비교했을 때 같은 크기를 저장하기 위해 더 많은 수의 셀이 필요하므로, 같은 크기의 저장 공간을 제공하기 위해서는 더 큰 비용이 요구됩니다.\n가격을 낮추면서도 속도가 요구되는 상황에서는 속도를 더 내기 위해 MLC를 SLC처럼 사용하기도 합니다. SLC 캐시 혹은 SLC 모드(mode)가 이에 속합니다.",
      "references": [
        {"[한] MLC": "https://ko.wikipedia.org/wiki/%EB%A9%80%ED%8B%B0_%EB%A0%88%EB%B2%A8_%EC%85%80"},
        {"MLC": "https://en.wikipedia.org/wiki/Multi-level_cell"}
      ]
    },
    {
      "question": "웨어 레벨링(wear leveling)은 ___위해 사용되는 기법이다.",
      "choices": [
        "셀의 데이터를 더 빠르게 읽기",
        "셀에 데이터를 더 빠르게 쓰기",
        "블록의 데이터 삭제 횟수를 최소화하기",
        "SSD의 수명을 늘리기"
      ],
      "answer": 4,
      "explanation": "만약 같은 셀(cell)을 계속하여 사용한다면 금방 수명이 다하여 더 이상 사용할 수 없게 되며 장치 오류 또는 데이터 손실이 발생하기도 합니다. 따라서 SSD의 컨트롤러가 특정 셀이 과도하게 사용되지 않고 모든 셀이 균등하게 사용될 수 있도록 조절하는데, 이를 웨어 레벨링(wear leveling)이라 합니다. 기술적으로 SSD의 쓰기 단위는 셀의 집합인 페이지(page)이기 때문에, 위의 웨어 레벨링에 대한 설명에서 ‘셀’을 ‘페이지’로 치환하는 것이 더 정확한 표현이 될 수 있습니다.",
      "references": [
        {"Wear leveling": "https://en.wikipedia.org/wiki/Wear_leveling"}
      ]
    },
    {
      "question": "SSD의 가비지 컬렉션(garbage collection)에 대한 설명으로 틀린 것은?",
      "choices": [
        "페이지 단위의 지우기 작업이 실행된다.",
        "쓰기가 증폭될 수 있다.",
        "시간이 오래 걸리는 작업이다.",
        "능동적으로 수행될 수도 있다."
      ],
      "answer": 1,
      "explanation": "SSD의 가비지 컬렉션(garbage collection, GC)은 여유 공간을 확보하기 위해 더 이상 사용되지 않는 공간을 정리하는 메모리 관리 기법입니다. SSD는 물리적 특성상 한번 사용한 공간은 지우지 않는 한 다시 사용할 수 없기 때문에 정리에는 반드시 지우는 동작이 동반됩니다. 이 때, 데이터 손실이 발생하지 않도록 사용 중인 페이지들은 새 블록에 옮긴 뒤에 기존 블록을 삭제하기 때문에 쓰기가 증폭될 수 있습니다.\nSSD는 쓰기와 지우기의 단위가 다릅니다. 쓰기는 셀의 집합인 페이지이지만, 지우기는 페이지의 집합인 블록입니다. 따라서 페이지 단위로는 지울 수 없습니다.\n추가적으로 가비지 컬렉션은 쓰기가 발생할 때 공간이 부족한 상황에서 수동적으로 실행되기도 하지만, SSD 컨트롤러가 트림(trim)을 지원할 경우 OS가 능동적으로 실행시켜 미리 공간을 확보해 두기도 합니다. 지우기는 쓰기에 비해 매우 느린 동작이므로 I/O 요청이 있을 때 가비지 컬렉션이 발생하는 것보다 성능이나 수명 측면에서 훨씬 효율적일 수 있습니다.",
      "references": [
        {"[한] GC": "https://kr.transcend-info.com/embedded/Essay-21"},
        {"GC": "https://en.wikipedia.org/wiki/Write_amplification#Garbage_collection"}
      ]
    }
  ]
}
